{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SWE Notes Welcome to my Software Engineering notebook! Here you'll find concise deep-dives into common algorithms, data structures, and C++ essentials\u2014all in Markdown. What's Inside Algorithms : Backtracking \u00b7 Greedy \u00b7 Dynamic Programming \u00b7 Graphs and more C++ : STL and language idioms Data Structures : Common implementations and usage patterns Why This Notebook? I created this collection to: - Serve as a personal reference for technical interviews - Document elegant solutions to common problems - Share knowledge with fellow software engineers Feel free to explore the sections and contribute if you find it useful! Getting Started Check out these popular sections: Dynamic Programming Data Structures C++ STL","title":"Home"},{"location":"#swe-notes","text":"Welcome to my Software Engineering notebook! Here you'll find concise deep-dives into common algorithms, data structures, and C++ essentials\u2014all in Markdown.","title":"SWE Notes"},{"location":"#whats-inside","text":"Algorithms : Backtracking \u00b7 Greedy \u00b7 Dynamic Programming \u00b7 Graphs and more C++ : STL and language idioms Data Structures : Common implementations and usage patterns","title":"What's Inside"},{"location":"#why-this-notebook","text":"I created this collection to: - Serve as a personal reference for technical interviews - Document elegant solutions to common problems - Share knowledge with fellow software engineers Feel free to explore the sections and contribute if you find it useful!","title":"Why This Notebook?"},{"location":"#getting-started","text":"Check out these popular sections: Dynamic Programming Data Structures C++ STL","title":"Getting Started"},{"location":"navigation/","text":"Navigation Home Algorithms Backtracking Data Structures Dynamic Programming Graphs Greedy Math Searching Sorting Strings C++ STL System Design URL Shortener Ad Click Aggregator Dropbox Live Comments Ticketmaster Tinder Uber Whatsapp YouTube YouTube Top K Object Oriented Programming Java Concepts Solid Principles Design Patterns C++ Concepts Solid Principles Design Patterns","title":"Navigation"},{"location":"navigation/#navigation","text":"Home Algorithms Backtracking Data Structures Dynamic Programming Graphs Greedy Math Searching Sorting Strings C++ STL System Design URL Shortener Ad Click Aggregator Dropbox Live Comments Ticketmaster Tinder Uber Whatsapp YouTube YouTube Top K Object Oriented Programming Java Concepts Solid Principles Design Patterns C++ Concepts Solid Principles Design Patterns","title":"Navigation"},{"location":"algorithms/data-structures/","text":"Data Structures A comprehensive guide to common data structures with implementation details and time complexity analysis. Arrays Arrays store elements in contiguous memory locations, providing O(1) access by index. // C++ array declaration int staticArray[5] = {1, 2, 3, 4, 5}; // Dynamic array (vector in C++) vector<int> dynamicArray = {1, 2, 3, 4, 5}; Time Complexities: - Access: O(1) - Search: O(n) - Insert/Delete at end: O(1) amortized - Insert/Delete at arbitrary position: O(n) Linked Lists Linked lists store elements in nodes, each pointing to the next node in the sequence. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; Time Complexities: - Access: O(n) - Search: O(n) - Insert/Delete at beginning: O(1) - Insert/Delete at end: O(n) (O(1) with tail pointer) - Insert/Delete at position: O(n) Stacks LIFO (Last In, First Out) data structure. stack<int> s; s.push(1); s.push(2); int top = s.top(); // 2 s.pop(); Time Complexities: - Push: O(1) - Pop: O(1) - Top: O(1) Queues FIFO (First In, First Out) data structure. queue<int> q; q.push(1); q.push(2); int front = q.front(); // 1 q.pop(); Time Complexities: - Push: O(1) - Pop: O(1) - Front: O(1) Hash Tables Hash tables map keys to values using a hash function. unordered_map<string, int> hashMap; hashMap[\"apple\"] = 5; int value = hashMap[\"apple\"]; // 5 Time Complexities: - Insert: O(1) average, O(n) worst - Delete: O(1) average, O(n) worst - Search: O(1) average, O(n) worst Trees Binary Tree struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; Binary Search Tree (BST) // BST Property: left->val < node->val < right->val // Search in BST TreeNode* search(TreeNode* root, int key) { if (!root || root->val == key) return root; if (key < root->val) return search(root->left, key); return search(root->right, key); } Time Complexities (Balanced BST): - Search: O(log n) - Insert: O(log n) - Delete: O(log n) Heaps A binary heap is a complete binary tree where each node is either greater than or equal to (max-heap) or less than or equal to (min-heap) its children. // Min-heap in C++ priority_queue<int, vector<int>, greater<int>> minHeap; minHeap.push(3); minHeap.push(1); minHeap.push(2); int min = minHeap.top(); // 1 Time Complexities: - Insert: O(log n) - Extract Min/Max: O(log n) - Peek: O(1) - Heapify: O(n) Graphs Graphs consist of nodes (vertices) and edges connecting them. Representation: Adjacency Matrix: vector<vector<int>> graph(n, vector<int>(n, 0)); // Add edge from u to v graph[u][v] = 1; Adjacency List: vector<vector<int>> graph(n); // Add edge from u to v graph[u].push_back(v); Time Complexities (Adjacency List): - Add Edge: O(1) - Remove Edge: O(E) where E is the number of edges - Check if edge exists: O(E) Trie A tree-like data structure used for storing a dynamic set of strings. struct TrieNode { TrieNode* children[26]; bool isEndOfWord; TrieNode() { isEndOfWord = false; for (int i = 0; i < 26; i++) children[i] = nullptr; } }; Time Complexities: - Insert: O(L) where L is the length of the string - Search: O(L) - Delete: O(L) Union-Find (Disjoint Set) Used to track disjoint sets and perform union operations on them. class DisjointSet { vector<int> parent, rank; public: DisjointSet(int n) { parent.resize(n); rank.resize(n, 0); for (int i = 0; i < n; i++) parent[i] = i; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } void unionSets(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return; if (rank[rootX] < rank[rootY]) parent[rootX] = rootY; else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX; else { parent[rootY] = rootX; rank[rootX]++; } } }; Time Complexities (with path compression and union by rank): - Find: O(\u03b1(n)) (effectively O(1)) - Union: O(\u03b1(n)) (effectively O(1))","title":"Data Structures"},{"location":"algorithms/data-structures/#data-structures","text":"A comprehensive guide to common data structures with implementation details and time complexity analysis.","title":"Data Structures"},{"location":"algorithms/data-structures/#arrays","text":"Arrays store elements in contiguous memory locations, providing O(1) access by index. // C++ array declaration int staticArray[5] = {1, 2, 3, 4, 5}; // Dynamic array (vector in C++) vector<int> dynamicArray = {1, 2, 3, 4, 5}; Time Complexities: - Access: O(1) - Search: O(n) - Insert/Delete at end: O(1) amortized - Insert/Delete at arbitrary position: O(n)","title":"Arrays"},{"location":"algorithms/data-structures/#linked-lists","text":"Linked lists store elements in nodes, each pointing to the next node in the sequence. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; Time Complexities: - Access: O(n) - Search: O(n) - Insert/Delete at beginning: O(1) - Insert/Delete at end: O(n) (O(1) with tail pointer) - Insert/Delete at position: O(n)","title":"Linked Lists"},{"location":"algorithms/data-structures/#stacks","text":"LIFO (Last In, First Out) data structure. stack<int> s; s.push(1); s.push(2); int top = s.top(); // 2 s.pop(); Time Complexities: - Push: O(1) - Pop: O(1) - Top: O(1)","title":"Stacks"},{"location":"algorithms/data-structures/#queues","text":"FIFO (First In, First Out) data structure. queue<int> q; q.push(1); q.push(2); int front = q.front(); // 1 q.pop(); Time Complexities: - Push: O(1) - Pop: O(1) - Front: O(1)","title":"Queues"},{"location":"algorithms/data-structures/#hash-tables","text":"Hash tables map keys to values using a hash function. unordered_map<string, int> hashMap; hashMap[\"apple\"] = 5; int value = hashMap[\"apple\"]; // 5 Time Complexities: - Insert: O(1) average, O(n) worst - Delete: O(1) average, O(n) worst - Search: O(1) average, O(n) worst","title":"Hash Tables"},{"location":"algorithms/data-structures/#trees","text":"","title":"Trees"},{"location":"algorithms/data-structures/#binary-tree","text":"struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} };","title":"Binary Tree"},{"location":"algorithms/data-structures/#binary-search-tree-bst","text":"// BST Property: left->val < node->val < right->val // Search in BST TreeNode* search(TreeNode* root, int key) { if (!root || root->val == key) return root; if (key < root->val) return search(root->left, key); return search(root->right, key); } Time Complexities (Balanced BST): - Search: O(log n) - Insert: O(log n) - Delete: O(log n)","title":"Binary Search Tree (BST)"},{"location":"algorithms/data-structures/#heaps","text":"A binary heap is a complete binary tree where each node is either greater than or equal to (max-heap) or less than or equal to (min-heap) its children. // Min-heap in C++ priority_queue<int, vector<int>, greater<int>> minHeap; minHeap.push(3); minHeap.push(1); minHeap.push(2); int min = minHeap.top(); // 1 Time Complexities: - Insert: O(log n) - Extract Min/Max: O(log n) - Peek: O(1) - Heapify: O(n)","title":"Heaps"},{"location":"algorithms/data-structures/#graphs","text":"Graphs consist of nodes (vertices) and edges connecting them. Representation: Adjacency Matrix: vector<vector<int>> graph(n, vector<int>(n, 0)); // Add edge from u to v graph[u][v] = 1; Adjacency List: vector<vector<int>> graph(n); // Add edge from u to v graph[u].push_back(v); Time Complexities (Adjacency List): - Add Edge: O(1) - Remove Edge: O(E) where E is the number of edges - Check if edge exists: O(E)","title":"Graphs"},{"location":"algorithms/data-structures/#trie","text":"A tree-like data structure used for storing a dynamic set of strings. struct TrieNode { TrieNode* children[26]; bool isEndOfWord; TrieNode() { isEndOfWord = false; for (int i = 0; i < 26; i++) children[i] = nullptr; } }; Time Complexities: - Insert: O(L) where L is the length of the string - Search: O(L) - Delete: O(L)","title":"Trie"},{"location":"algorithms/data-structures/#union-find-disjoint-set","text":"Used to track disjoint sets and perform union operations on them. class DisjointSet { vector<int> parent, rank; public: DisjointSet(int n) { parent.resize(n); rank.resize(n, 0); for (int i = 0; i < n; i++) parent[i] = i; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } void unionSets(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return; if (rank[rootX] < rank[rootY]) parent[rootX] = rootY; else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX; else { parent[rootY] = rootX; rank[rootX]++; } } }; Time Complexities (with path compression and union by rank): - Find: O(\u03b1(n)) (effectively O(1)) - Union: O(\u03b1(n)) (effectively O(1))","title":"Union-Find (Disjoint Set)"},{"location":"algorithms/graph/","text":"Graph Algorithms A comprehensive guide to common graph algorithms with implementation details and use cases. Graph Representations Adjacency Matrix vector<vector<int>> graph(n, vector<int>(n, 0)); // Add edge from u to v graph[u][v] = 1; // For weighted graph: graph[u][v] = weight Pros: - O(1) lookup time to check if edge exists - Simple implementation for dense graphs Cons: - O(V\u00b2) space complexity - Inefficient for sparse graphs Adjacency List vector<vector<int>> graph(n); // Add edge from u to v graph[u].push_back(v); // For weighted graph: vector<vector<pair<int, int>>> graph(n); // Add edge from u to v with weight w graph[u].push_back({v, w}); Pros: - Space efficient for sparse graphs: O(V+E) - Faster to iterate over edges Cons: - O(degree(v)) time to check if edge exists - Less intuitive for dense graphs Graph Traversal Depth-First Search (DFS) void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited) { visited[node] = true; cout << node << \" \"; for (int neighbor : graph[node]) { if (!visited[neighbor]) { dfs(graph, neighbor, visited); } } } void dfsTraversal(vector<vector<int>>& graph, int start) { int n = graph.size(); vector<bool> visited(n, false); dfs(graph, start, visited); } Time Complexity: O(V + E) Space Complexity: O(V) for the recursion stack Breadth-First Search (BFS) void bfs(vector<vector<int>>& graph, int start) { int n = graph.size(); vector<bool> visited(n, false); queue<int> q; visited[start] = true; q.push(start); while (!q.empty()) { int node = q.front(); q.pop(); cout << node << \" \"; for (int neighbor : graph[node]) { if (!visited[neighbor]) { visited[neighbor] = true; q.push(neighbor); } } } } Time Complexity: O(V + E) Space Complexity: O(V) for the queue Shortest Path Algorithms Dijkstra's Algorithm For finding shortest paths from a source to all vertices in a weighted graph with non-negative weights. vector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int start) { int n = graph.size(); vector<int> dist(n, INT_MAX); dist[start] = 0; priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; pq.push({0, start}); while (!pq.empty()) { int u = pq.top().second; int d = pq.top().first; pq.pop(); if (d > dist[u]) continue; for (auto& edge : graph[u]) { int v = edge.first; int weight = edge.second; if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pq.push({dist[v], v}); } } } return dist; } Time Complexity: O(E log V) Bellman-Ford Algorithm For finding shortest paths from a source to all vertices, even with negative edge weights (but no negative cycles). vector<int> bellmanFord(int n, vector<vector<int>>& edges, int start) { vector<int> dist(n, INT_MAX); dist[start] = 0; // Relax all edges V-1 times for (int i = 0; i < n - 1; i++) { for (auto& edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; } } } // Check for negative cycles for (auto& edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { cout << \"Graph contains negative weight cycle\" << endl; return {}; } } return dist; } Time Complexity: O(V * E) Floyd-Warshall Algorithm For finding shortest paths between all pairs of vertices. vector<vector<int>> floydWarshall(vector<vector<int>>& graph) { int n = graph.size(); vector<vector<int>> dist = graph; // Initialize the distance matrix for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i != j && dist[i][j] == 0) { dist[i][j] = INT_MAX; } } } // Update the shortest path for all pairs of vertices for (int k = 0; k < n; k++) { for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; } } } } return dist; } Time Complexity: O(V\u00b3) Minimum Spanning Tree Kruskal's Algorithm int kruskalMST(int n, vector<vector<int>>& edges) { // Sort edges by weight sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; }); // Initialize disjoint set vector<int> parent(n); vector<int> rank(n, 0); for (int i = 0; i < n; i++) { parent[i] = i; } function<int(int)> find = [&](int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; }; auto unionSets = [&](int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; if (rank[rootX] < rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] > rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; }; int totalWeight = 0; int edgesAdded = 0; for (auto& edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (unionSets(u, v)) { totalWeight += weight; edgesAdded++; if (edgesAdded == n - 1) break; } } return totalWeight; } Time Complexity: O(E log E) Prim's Algorithm int primMST(vector<vector<pair<int, int>>>& graph) { int n = graph.size(); vector<bool> inMST(n, false); vector<int> key(n, INT_MAX); priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; key[0] = 0; pq.push({0, 0}); // {weight, vertex} int totalWeight = 0; while (!pq.empty()) { int u = pq.top().second; int weight = pq.top().first; pq.pop(); if (inMST[u]) continue; inMST[u] = true; totalWeight += weight; for (auto& neighbor : graph[u]) { int v = neighbor.first; int w = neighbor.second; if (!inMST[v] && w < key[v]) { key[v] = w; pq.push({key[v], v}); } } } return totalWeight; } Time Complexity: O(E log V) Strongly Connected Components Kosaraju's Algorithm void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited, vector<int>& order) { visited[node] = true; for (int neighbor : graph[node]) { if (!visited[neighbor]) { dfs(graph, neighbor, visited, order); } } order.push_back(node); } void dfsReverse(vector<vector<int>>& reversedGraph, int node, vector<bool>& visited, vector<int>& component) { visited[node] = true; component.push_back(node); for (int neighbor : reversedGraph[node]) { if (!visited[neighbor]) { dfsReverse(reversedGraph, neighbor, visited, component); } } } vector<vector<int>> kosarajuSCC(vector<vector<int>>& graph) { int n = graph.size(); vector<bool> visited(n, false); vector<int> order; // Step 1: DFS and record finish order for (int i = 0; i < n; i++) { if (!visited[i]) { dfs(graph, i, visited, order); } } // Step 2: Reverse the graph vector<vector<int>> reversedGraph(n); for (int u = 0; u < n; u++) { for (int v : graph[u]) { reversedGraph[v].push_back(u); } } // Step 3: DFS on reversed graph in finish order fill(visited.begin(), visited.end(), false); vector<vector<int>> scc; for (int i = n - 1; i >= 0; i--) { int node = order[i]; if (!visited[node]) { vector<int> component; dfsReverse(reversedGraph, node, visited, component); scc.push_back(component); } } return scc; } Time Complexity: O(V + E) Space Complexity: O(V) for the recursion stack and visited array","title":"Graphs"},{"location":"algorithms/graph/#graph-algorithms","text":"A comprehensive guide to common graph algorithms with implementation details and use cases.","title":"Graph Algorithms"},{"location":"algorithms/graph/#graph-representations","text":"","title":"Graph Representations"},{"location":"algorithms/graph/#adjacency-matrix","text":"vector<vector<int>> graph(n, vector<int>(n, 0)); // Add edge from u to v graph[u][v] = 1; // For weighted graph: graph[u][v] = weight Pros: - O(1) lookup time to check if edge exists - Simple implementation for dense graphs Cons: - O(V\u00b2) space complexity - Inefficient for sparse graphs","title":"Adjacency Matrix"},{"location":"algorithms/graph/#adjacency-list","text":"vector<vector<int>> graph(n); // Add edge from u to v graph[u].push_back(v); // For weighted graph: vector<vector<pair<int, int>>> graph(n); // Add edge from u to v with weight w graph[u].push_back({v, w}); Pros: - Space efficient for sparse graphs: O(V+E) - Faster to iterate over edges Cons: - O(degree(v)) time to check if edge exists - Less intuitive for dense graphs","title":"Adjacency List"},{"location":"algorithms/graph/#graph-traversal","text":"","title":"Graph Traversal"},{"location":"algorithms/graph/#depth-first-search-dfs","text":"void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited) { visited[node] = true; cout << node << \" \"; for (int neighbor : graph[node]) { if (!visited[neighbor]) { dfs(graph, neighbor, visited); } } } void dfsTraversal(vector<vector<int>>& graph, int start) { int n = graph.size(); vector<bool> visited(n, false); dfs(graph, start, visited); } Time Complexity: O(V + E) Space Complexity: O(V) for the recursion stack","title":"Depth-First Search (DFS)"},{"location":"algorithms/graph/#breadth-first-search-bfs","text":"void bfs(vector<vector<int>>& graph, int start) { int n = graph.size(); vector<bool> visited(n, false); queue<int> q; visited[start] = true; q.push(start); while (!q.empty()) { int node = q.front(); q.pop(); cout << node << \" \"; for (int neighbor : graph[node]) { if (!visited[neighbor]) { visited[neighbor] = true; q.push(neighbor); } } } } Time Complexity: O(V + E) Space Complexity: O(V) for the queue","title":"Breadth-First Search (BFS)"},{"location":"algorithms/graph/#shortest-path-algorithms","text":"","title":"Shortest Path Algorithms"},{"location":"algorithms/graph/#dijkstras-algorithm","text":"For finding shortest paths from a source to all vertices in a weighted graph with non-negative weights. vector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int start) { int n = graph.size(); vector<int> dist(n, INT_MAX); dist[start] = 0; priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; pq.push({0, start}); while (!pq.empty()) { int u = pq.top().second; int d = pq.top().first; pq.pop(); if (d > dist[u]) continue; for (auto& edge : graph[u]) { int v = edge.first; int weight = edge.second; if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pq.push({dist[v], v}); } } } return dist; } Time Complexity: O(E log V)","title":"Dijkstra's Algorithm"},{"location":"algorithms/graph/#bellman-ford-algorithm","text":"For finding shortest paths from a source to all vertices, even with negative edge weights (but no negative cycles). vector<int> bellmanFord(int n, vector<vector<int>>& edges, int start) { vector<int> dist(n, INT_MAX); dist[start] = 0; // Relax all edges V-1 times for (int i = 0; i < n - 1; i++) { for (auto& edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; } } } // Check for negative cycles for (auto& edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { cout << \"Graph contains negative weight cycle\" << endl; return {}; } } return dist; } Time Complexity: O(V * E)","title":"Bellman-Ford Algorithm"},{"location":"algorithms/graph/#floyd-warshall-algorithm","text":"For finding shortest paths between all pairs of vertices. vector<vector<int>> floydWarshall(vector<vector<int>>& graph) { int n = graph.size(); vector<vector<int>> dist = graph; // Initialize the distance matrix for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i != j && dist[i][j] == 0) { dist[i][j] = INT_MAX; } } } // Update the shortest path for all pairs of vertices for (int k = 0; k < n; k++) { for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; } } } } return dist; } Time Complexity: O(V\u00b3)","title":"Floyd-Warshall Algorithm"},{"location":"algorithms/graph/#minimum-spanning-tree","text":"","title":"Minimum Spanning Tree"},{"location":"algorithms/graph/#kruskals-algorithm","text":"int kruskalMST(int n, vector<vector<int>>& edges) { // Sort edges by weight sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; }); // Initialize disjoint set vector<int> parent(n); vector<int> rank(n, 0); for (int i = 0; i < n; i++) { parent[i] = i; } function<int(int)> find = [&](int x) { if (parent[x] != x) { parent[x] = find(parent[x]); } return parent[x]; }; auto unionSets = [&](int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return false; if (rank[rootX] < rank[rootY]) { parent[rootX] = rootY; } else if (rank[rootX] > rank[rootY]) { parent[rootY] = rootX; } else { parent[rootY] = rootX; rank[rootX]++; } return true; }; int totalWeight = 0; int edgesAdded = 0; for (auto& edge : edges) { int u = edge[0]; int v = edge[1]; int weight = edge[2]; if (unionSets(u, v)) { totalWeight += weight; edgesAdded++; if (edgesAdded == n - 1) break; } } return totalWeight; } Time Complexity: O(E log E)","title":"Kruskal's Algorithm"},{"location":"algorithms/graph/#prims-algorithm","text":"int primMST(vector<vector<pair<int, int>>>& graph) { int n = graph.size(); vector<bool> inMST(n, false); vector<int> key(n, INT_MAX); priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; key[0] = 0; pq.push({0, 0}); // {weight, vertex} int totalWeight = 0; while (!pq.empty()) { int u = pq.top().second; int weight = pq.top().first; pq.pop(); if (inMST[u]) continue; inMST[u] = true; totalWeight += weight; for (auto& neighbor : graph[u]) { int v = neighbor.first; int w = neighbor.second; if (!inMST[v] && w < key[v]) { key[v] = w; pq.push({key[v], v}); } } } return totalWeight; } Time Complexity: O(E log V)","title":"Prim's Algorithm"},{"location":"algorithms/graph/#strongly-connected-components","text":"","title":"Strongly Connected Components"},{"location":"algorithms/graph/#kosarajus-algorithm","text":"void dfs(vector<vector<int>>& graph, int node, vector<bool>& visited, vector<int>& order) { visited[node] = true; for (int neighbor : graph[node]) { if (!visited[neighbor]) { dfs(graph, neighbor, visited, order); } } order.push_back(node); } void dfsReverse(vector<vector<int>>& reversedGraph, int node, vector<bool>& visited, vector<int>& component) { visited[node] = true; component.push_back(node); for (int neighbor : reversedGraph[node]) { if (!visited[neighbor]) { dfsReverse(reversedGraph, neighbor, visited, component); } } } vector<vector<int>> kosarajuSCC(vector<vector<int>>& graph) { int n = graph.size(); vector<bool> visited(n, false); vector<int> order; // Step 1: DFS and record finish order for (int i = 0; i < n; i++) { if (!visited[i]) { dfs(graph, i, visited, order); } } // Step 2: Reverse the graph vector<vector<int>> reversedGraph(n); for (int u = 0; u < n; u++) { for (int v : graph[u]) { reversedGraph[v].push_back(u); } } // Step 3: DFS on reversed graph in finish order fill(visited.begin(), visited.end(), false); vector<vector<int>> scc; for (int i = n - 1; i >= 0; i--) { int node = order[i]; if (!visited[node]) { vector<int> component; dfsReverse(reversedGraph, node, visited, component); scc.push_back(component); } } return scc; } Time Complexity: O(V + E) Space Complexity: O(V) for the recursion stack and visited array","title":"Kosaraju's Algorithm"},{"location":"algorithms/sorting/","text":"Sorting Algorithms This document covers common sorting algorithms, their implementations, time and space complexities, and practical use cases. Bubble Sort A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order. void bubbleSort(vector<int>& arr) { int n = arr.size(); bool swapped; for (int i = 0; i < n - 1; i++) { swapped = false; for (int j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { swap(arr[j], arr[j + 1]); swapped = true; } } // If no swapping occurred in this pass, array is sorted if (!swapped) { break; } } } Time Complexity: - Best: O(n) when array is already sorted - Average: O(n\u00b2) - Worst: O(n\u00b2) Space Complexity: O(1) Advantages: - Simple to understand and implement - Works well for small datasets - Stable sort (doesn't change relative order of equal elements) Disadvantages: - Inefficient for large datasets - Poor performance compared to other algorithms Selection Sort Repeatedly selects the smallest (or largest) element from the unsorted portion and puts it at the beginning (or end). void selectionSort(vector<int>& arr) { int n = arr.size(); for (int i = 0; i < n - 1; i++) { int min_idx = i; for (int j = i + 1; j < n; j++) { if (arr[j] < arr[min_idx]) { min_idx = j; } } // Swap the found minimum element with the element at index i if (min_idx != i) { swap(arr[i], arr[min_idx]); } } } Time Complexity: - Best: O(n\u00b2) - Average: O(n\u00b2) - Worst: O(n\u00b2) Space Complexity: O(1) Advantages: - Simple implementation - Performs well on small datasets - Minimizes the number of swaps (O(n) swaps) Disadvantages: - Inefficient for large datasets - Not stable Insertion Sort Builds the sorted array one element at a time by repeatedly taking the next element and inserting it into the already-sorted part of the array. void insertionSort(vector<int>& arr) { int n = arr.size(); for (int i = 1; i < n; i++) { int key = arr[i]; int j = i - 1; // Move elements greater than key to one position ahead while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } } Time Complexity: - Best: O(n) when array is already sorted - Average: O(n\u00b2) - Worst: O(n\u00b2) Space Complexity: O(1) Advantages: - Simple implementation - Efficient for small datasets - Stable sort - Adaptive (efficient for partially sorted arrays) - Works well for arrays that are almost sorted - Online algorithm (can sort as data arrives) Disadvantages: - Inefficient for large datasets Merge Sort A divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves. void merge(vector<int>& arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; // Create temporary arrays vector<int> L(n1), R(n2); // Copy data to temporary arrays for (int i = 0; i < n1; i++) { L[i] = arr[left + i]; } for (int j = 0; j < n2; j++) { R[j] = arr[mid + 1 + j]; } // Merge the temporary arrays back into arr[left..right] int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // Copy the remaining elements of L[], if any while (i < n1) { arr[k] = L[i]; i++; k++; } // Copy the remaining elements of R[], if any while (j < n2) { arr[k] = R[j]; j++; k++; } } void mergeSort(vector<int>& arr, int left, int right) { if (left < right) { int mid = left + (right - left) / 2; // Sort first and second halves mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // Merge the sorted halves merge(arr, left, mid, right); } } // Wrapper function void mergeSort(vector<int>& arr) { mergeSort(arr, 0, arr.size() - 1); } Time Complexity: - Best: O(n log n) - Average: O(n log n) - Worst: O(n log n) Space Complexity: O(n) Advantages: - Guaranteed O(n log n) performance - Stable sort - Works well for linked lists - External sorting (when data doesn't fit in memory) Disadvantages: - Requires extra space - Slower for small datasets compared to insertion sort - Not in-place (although there are in-place variations) Quick Sort Another divide-and-conquer algorithm that selects a 'pivot' element and partitions the array around the pivot. int partition(vector<int>& arr, int low, int high) { int pivot = arr[high]; // Choose the rightmost element as pivot int i = low - 1; // Index of smaller element for (int j = low; j < high; j++) { // If current element is smaller than the pivot if (arr[j] < pivot) { i++; swap(arr[i], arr[j]); } } // Place pivot in its correct position swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(vector<int>& arr, int low, int high) { if (low < high) { // Partition the array int pi = partition(arr, low, high); // Sort elements before and after partition quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } // Wrapper function void quickSort(vector<int>& arr) { quickSort(arr, 0, arr.size() - 1); } Time Complexity: - Best: O(n log n) - Average: O(n log n) - Worst: O(n\u00b2) when array is already sorted and pivot is always the smallest/largest element Space Complexity: O(log n) for the recursive call stack Advantages: - Typically faster in practice than other O(n log n) algorithms - In-place sorting - Cache-friendly - Tail-recursive, which can be optimized Disadvantages: - Worst-case O(n\u00b2) performance - Not stable - Poor pivot selection can lead to inefficient sorting Randomized Quick Sort To avoid worst-case scenarios, we can choose a random pivot: int randomPartition(vector<int>& arr, int low, int high) { // Generate a random index between low and high int random = low + rand() % (high - low + 1); // Swap the random element with the last element swap(arr[random], arr[high]); // Now use the standard partition method return partition(arr, low, high); } void randomizedQuickSort(vector<int>& arr, int low, int high) { if (low < high) { int pi = randomPartition(arr, low, high); randomizedQuickSort(arr, low, pi - 1); randomizedQuickSort(arr, pi + 1, high); } }","title":"Sorting"},{"location":"algorithms/sorting/#sorting-algorithms","text":"This document covers common sorting algorithms, their implementations, time and space complexities, and practical use cases.","title":"Sorting Algorithms"},{"location":"algorithms/sorting/#bubble-sort","text":"A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they're in the wrong order. void bubbleSort(vector<int>& arr) { int n = arr.size(); bool swapped; for (int i = 0; i < n - 1; i++) { swapped = false; for (int j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { swap(arr[j], arr[j + 1]); swapped = true; } } // If no swapping occurred in this pass, array is sorted if (!swapped) { break; } } } Time Complexity: - Best: O(n) when array is already sorted - Average: O(n\u00b2) - Worst: O(n\u00b2) Space Complexity: O(1) Advantages: - Simple to understand and implement - Works well for small datasets - Stable sort (doesn't change relative order of equal elements) Disadvantages: - Inefficient for large datasets - Poor performance compared to other algorithms","title":"Bubble Sort"},{"location":"algorithms/sorting/#selection-sort","text":"Repeatedly selects the smallest (or largest) element from the unsorted portion and puts it at the beginning (or end). void selectionSort(vector<int>& arr) { int n = arr.size(); for (int i = 0; i < n - 1; i++) { int min_idx = i; for (int j = i + 1; j < n; j++) { if (arr[j] < arr[min_idx]) { min_idx = j; } } // Swap the found minimum element with the element at index i if (min_idx != i) { swap(arr[i], arr[min_idx]); } } } Time Complexity: - Best: O(n\u00b2) - Average: O(n\u00b2) - Worst: O(n\u00b2) Space Complexity: O(1) Advantages: - Simple implementation - Performs well on small datasets - Minimizes the number of swaps (O(n) swaps) Disadvantages: - Inefficient for large datasets - Not stable","title":"Selection Sort"},{"location":"algorithms/sorting/#insertion-sort","text":"Builds the sorted array one element at a time by repeatedly taking the next element and inserting it into the already-sorted part of the array. void insertionSort(vector<int>& arr) { int n = arr.size(); for (int i = 1; i < n; i++) { int key = arr[i]; int j = i - 1; // Move elements greater than key to one position ahead while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } } Time Complexity: - Best: O(n) when array is already sorted - Average: O(n\u00b2) - Worst: O(n\u00b2) Space Complexity: O(1) Advantages: - Simple implementation - Efficient for small datasets - Stable sort - Adaptive (efficient for partially sorted arrays) - Works well for arrays that are almost sorted - Online algorithm (can sort as data arrives) Disadvantages: - Inefficient for large datasets","title":"Insertion Sort"},{"location":"algorithms/sorting/#merge-sort","text":"A divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves. void merge(vector<int>& arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; // Create temporary arrays vector<int> L(n1), R(n2); // Copy data to temporary arrays for (int i = 0; i < n1; i++) { L[i] = arr[left + i]; } for (int j = 0; j < n2; j++) { R[j] = arr[mid + 1 + j]; } // Merge the temporary arrays back into arr[left..right] int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // Copy the remaining elements of L[], if any while (i < n1) { arr[k] = L[i]; i++; k++; } // Copy the remaining elements of R[], if any while (j < n2) { arr[k] = R[j]; j++; k++; } } void mergeSort(vector<int>& arr, int left, int right) { if (left < right) { int mid = left + (right - left) / 2; // Sort first and second halves mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // Merge the sorted halves merge(arr, left, mid, right); } } // Wrapper function void mergeSort(vector<int>& arr) { mergeSort(arr, 0, arr.size() - 1); } Time Complexity: - Best: O(n log n) - Average: O(n log n) - Worst: O(n log n) Space Complexity: O(n) Advantages: - Guaranteed O(n log n) performance - Stable sort - Works well for linked lists - External sorting (when data doesn't fit in memory) Disadvantages: - Requires extra space - Slower for small datasets compared to insertion sort - Not in-place (although there are in-place variations)","title":"Merge Sort"},{"location":"algorithms/sorting/#quick-sort","text":"Another divide-and-conquer algorithm that selects a 'pivot' element and partitions the array around the pivot. int partition(vector<int>& arr, int low, int high) { int pivot = arr[high]; // Choose the rightmost element as pivot int i = low - 1; // Index of smaller element for (int j = low; j < high; j++) { // If current element is smaller than the pivot if (arr[j] < pivot) { i++; swap(arr[i], arr[j]); } } // Place pivot in its correct position swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(vector<int>& arr, int low, int high) { if (low < high) { // Partition the array int pi = partition(arr, low, high); // Sort elements before and after partition quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } // Wrapper function void quickSort(vector<int>& arr) { quickSort(arr, 0, arr.size() - 1); } Time Complexity: - Best: O(n log n) - Average: O(n log n) - Worst: O(n\u00b2) when array is already sorted and pivot is always the smallest/largest element Space Complexity: O(log n) for the recursive call stack Advantages: - Typically faster in practice than other O(n log n) algorithms - In-place sorting - Cache-friendly - Tail-recursive, which can be optimized Disadvantages: - Worst-case O(n\u00b2) performance - Not stable - Poor pivot selection can lead to inefficient sorting","title":"Quick Sort"},{"location":"algorithms/sorting/#randomized-quick-sort","text":"To avoid worst-case scenarios, we can choose a random pivot: int randomPartition(vector<int>& arr, int low, int high) { // Generate a random index between low and high int random = low + rand() % (high - low + 1); // Swap the random element with the last element swap(arr[random], arr[high]); // Now use the standard partition method return partition(arr, low, high); } void randomizedQuickSort(vector<int>& arr, int low, int high) { if (low < high) { int pi = randomPartition(arr, low, high); randomizedQuickSort(arr, low, pi - 1); randomizedQuickSort(arr, pi + 1, high); } }","title":"Randomized Quick Sort"},{"location":"algorithms/string/","text":"String Algorithms Polynomial Rolling Hash","title":"Strings"},{"location":"algorithms/string/#string-algorithms","text":"Polynomial Rolling Hash","title":"String Algorithms"},{"location":"cpp/stl/","text":"C++ Standard Template Library (STL) The C++ STL is a powerful collection of template classes and functions providing common data structures and algorithms. Containers Sequence Containers vector Dynamic array with automatic resizing. #include <vector> vector<int> vec; // Empty vector vector<int> vec = {1, 2, 3, 4}; // Initialization with values vector<int> vec(10, 0); // Vector of size 10 with all values as 0 // Common operations vec.push_back(5); // Add element at the end vec.pop_back(); // Remove last element vec.size(); // Get size vec.empty(); // Check if empty vec.clear(); // Remove all elements vec.resize(5); // Resize vector vec[0]; // Access element (no bounds checking) vec.at(0); // Access element (with bounds checking) vec.front(); // Access first element vec.back(); // Access last element Time Complexity: - Access: O(1) - Insert/Erase at end: O(1) amortized - Insert/Erase at arbitrary position: O(n) deque Double-ended queue supporting fast insertion and deletion at both ends. #include <deque> deque<int> dq; // Empty deque deque<int> dq = {1, 2, 3, 4}; // Initialization with values // Common operations dq.push_back(5); // Add element at the end dq.push_front(0); // Add element at the beginning dq.pop_back(); // Remove last element dq.pop_front(); // Remove first element dq.size(); // Get size dq.empty(); // Check if empty dq.clear(); // Remove all elements dq[0]; // Access element (no bounds checking) dq.at(0); // Access element (with bounds checking) dq.front(); // Access first element dq.back(); // Access last element Time Complexity: - Access: O(1) - Insert/Erase at beginning/end: O(1) amortized - Insert/Erase at arbitrary position: O(n) list Doubly-linked list. #include <list> list<int> lst; // Empty list list<int> lst = {1, 2, 3, 4}; // Initialization with values // Common operations lst.push_back(5); // Add element at the end lst.push_front(0); // Add element at the beginning lst.pop_back(); // Remove last element lst.pop_front(); // Remove first element lst.size(); // Get size lst.empty(); // Check if empty lst.clear(); // Remove all elements auto it = lst.begin(); // Iterator to first element lst.insert(it, 10); // Insert 10 before position of iterator lst.erase(it); // Erase element at iterator lst.front(); // Access first element lst.back(); // Access last element lst.sort(); // Sort the list lst.reverse(); // Reverse the list lst.merge(list2); // Merge two sorted lists lst.splice(it, list2); // Insert list2 at position it Time Complexity: - Access: O(n) - Insert/Erase with known position: O(1) - Search: O(n) forward_list Singly-linked list. #include <forward_list> forward_list<int> fl; // Empty forward_list forward_list<int> fl = {1, 2, 3};// Initialization with values // Common operations fl.push_front(0); // Add element at the beginning fl.pop_front(); // Remove first element fl.empty(); // Check if empty fl.clear(); // Remove all elements auto it = fl.begin(); // Iterator to first element auto it_before = fl.before_begin(); // Iterator before first element fl.insert_after(it, 10); // Insert 10 after position of iterator fl.erase_after(it); // Erase element after iterator fl.front(); // Access first element fl.sort(); // Sort the forward_list fl.reverse(); // Reverse the forward_list Time Complexity: - Access: O(n) - Insert/Erase with known position: O(1) - Search: O(n) array Fixed-size array. #include <array> array<int, 5> arr; // Uninitialized array of size 5 array<int, 5> arr = {1, 2, 3, 4, 5}; // Initialization with values // Common operations arr.size(); // Get size arr.empty(); // Check if empty arr.fill(0); // Fill with 0s arr[0]; // Access element (no bounds checking) arr.at(0); // Access element (with bounds checking) arr.front(); // Access first element arr.back(); // Access last element Time Complexity: - Access: O(1) - Insert/Erase: Not supported (fixed size) Associative Containers set Collection of unique keys, sorted by keys. #include <set> set<int> s; // Empty set set<int> s = {1, 2, 3, 4}; // Initialization with values // Common operations s.insert(5); // Insert element s.erase(3); // Remove element with value 3 s.size(); // Get size s.empty(); // Check if empty s.clear(); // Remove all elements s.find(2); // Find element with value 2 s.count(2); // Count elements with value 2 (0 or 1) s.lower_bound(3); // Iterator to first element >= 3 s.upper_bound(3); // Iterator to first element > 3 Time Complexity: - Insert/Erase/Find: O(log n) multiset Collection of keys, sorted by keys (allows duplicates). #include <set> multiset<int> ms; // Empty multiset multiset<int> ms = {1, 2, 2, 3}; // Initialization with values // Common operations (similar to set) ms.insert(5); // Insert element ms.erase(3); // Remove all elements with value 3 auto it = ms.find(2); // Find first element with value 2 ms.erase(it); // Remove specific occurrence of 2 ms.count(2); // Count elements with value 2 Time Complexity: - Insert/Erase/Find: O(log n) map Collection of key-value pairs, sorted by keys, keys are unique. #include <map> map<string, int> mp; // Empty map {% raw %} map<string, int> mp = {{\"apple\", 5}, {\"banana\", 3}}; // Initialization with values {% endraw %} // Common operations mp[\"orange\"] = 2; // Insert or update key-value pair mp.insert({\"pear\", 4}); // Insert key-value pair mp.insert(make_pair(\"grape\", 6));// Another way to insert mp.erase(\"apple\"); // Remove element with key \"apple\" mp.size(); // Get size mp.empty(); // Check if empty mp.clear(); // Remove all elements mp.find(\"banana\"); // Find element with key \"banana\" mp.count(\"banana\"); // Count elements with key \"banana\" (0 or 1) Time Complexity: - Insert/Erase/Find: O(log n) multimap Collection of key-value pairs, sorted by keys (allows duplicate keys). #include <map> multimap<string, int> mm; // Empty multimap mm.insert({\"apple\", 5}); // Insert key-value pair mm.insert({\"apple\", 3}); // Insert another with same key Time Complexity: - Insert/Erase/Find: O(log n) Unordered Associative Containers unordered_set Collection of unique keys, hashed by keys. #include <unordered_set> unordered_set<int> us; // Empty unordered_set unordered_set<int> us = {1, 2, 3, 4}; // Initialization with values // Common operations (similar to set, but unordered) us.insert(5); // Insert element us.erase(3); // Remove element with value 3 us.find(2); // Find element with value 2 us.count(2); // Count elements with value 2 (0 or 1) Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case unordered_multiset Collection of keys, hashed by keys (allows duplicates). #include <unordered_set> unordered_multiset<int> ums; // Empty unordered_multiset ums.insert(2); // Insert element ums.insert(2); // Insert duplicate Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case unordered_map Collection of key-value pairs, hashed by keys, keys are unique. #include <unordered_map> unordered_map<string, int> um; // Empty unordered_map um[\"apple\"] = 5; // Insert or update key-value pair um.insert({\"banana\", 3}); // Insert key-value pair Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case unordered_multimap Collection of key-value pairs, hashed by keys (allows duplicate keys). #include <unordered_map> unordered_multimap<string, int> umm; // Empty unordered_multimap umm.insert({\"apple\", 5}); // Insert key-value pair umm.insert({\"apple\", 3}); // Insert another with same key Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case Container Adaptors stack LIFO (Last In, First Out) data structure. #include <stack> stack<int> stk; // Empty stack stk.push(1); // Add element to top stk.push(2); // Add element to top int top = stk.top(); // Access top element (2) stk.pop(); // Remove top element stk.size(); // Get size stk.empty(); // Check if empty Time Complexity: - Push/Pop/Top: O(1) queue FIFO (First In, First Out) data structure. #include <queue> queue<int> q; // Empty queue q.push(1); // Add element to back q.push(2); // Add element to back int front = q.front(); // Access front element (1) int back = q.back(); // Access back element (2) q.pop(); // Remove front element q.size(); // Get size q.empty(); // Check if empty Time Complexity: - Push/Pop/Front/Back: O(1) priority_queue Provides constant time lookup of the largest (by default) element. #include <queue> // Max heap (default) priority_queue<int> pq; // Empty priority queue pq.push(3); // Add element pq.push(5); // Add element pq.push(1); // Add element int top = pq.top(); // Access largest element (5) pq.pop(); // Remove largest element pq.size(); // Get size pq.empty(); // Check if empty // Min heap priority_queue<int, vector<int>, greater<int>> min_pq; min_pq.push(3); // Add element min_pq.push(5); // Add element min_pq.push(1); // Add element int min_top = min_pq.top(); // Access smallest element (1) Time Complexity: - Push/Pop: O(log n) - Top: O(1) Algorithms STL provides various algorithms for common operations on containers. #include <algorithm> vector<int> v = {5, 2, 8, 1, 3}; // Sorting sort(v.begin(), v.end()); // Sort in ascending order sort(v.begin(), v.end(), greater<int>()); // Sort in descending order // Binary search (on sorted range) binary_search(v.begin(), v.end(), 3); // Returns true if 3 is in vector lower_bound(v.begin(), v.end(), 3); // Iterator to first element >= 3 upper_bound(v.begin(), v.end(), 3); // Iterator to first element > 3 // Min/Max *min_element(v.begin(), v.end()); // Smallest element *max_element(v.begin(), v.end()); // Largest element // Finding find(v.begin(), v.end(), 3); // Iterator to first occurrence of 3 count(v.begin(), v.end(), 3); // Count occurrences of 3 // Manipulation reverse(v.begin(), v.end()); // Reverse the vector rotate(v.begin(), v.begin() + 2, v.end()); // Rotate vector left by 2 positions random_shuffle(v.begin(), v.end()); // Randomly shuffle elements // Heap operations make_heap(v.begin(), v.end()); // Convert range to a heap push_heap(v.begin(), v.end()); // Add element to heap pop_heap(v.begin(), v.end()); // Move largest element to end and reconstitute heap // Numeric #include <numeric> accumulate(v.begin(), v.end(), 0); // Sum of elements (starting with 0) partial_sum(v.begin(), v.end(), result.begin()); // Partial sums Iterators Iterators are used to access and traverse container elements. vector<int> v = {1, 2, 3, 4, 5}; // Types of iterators auto it = v.begin(); // Regular iterator auto rit = v.rbegin(); // Reverse iterator auto cit = v.cbegin(); // Constant iterator auto crit = v.crbegin(); // Constant reverse iterator // Iterator operations it++; // Move to next element it--; // Move to previous element it += 2; // Move forward by 2 (random access) *it; // Access element it = v.end(); // Iterator to one past the last element Utility Classes pair Holds two values of possibly different types. #include <utility> pair<string, int> p(\"apple\", 5); // Create pair auto p = make_pair(\"apple\", 5); // Alternative creation string first = p.first; // Access first element int second = p.second; // Access second element tuple Holds a fixed-size collection of elements of different types. #include <tuple> tuple<string, int, double> t(\"apple\", 5, 3.14); // Create tuple auto t = make_tuple(\"apple\", 5, 3.14); // Alternative creation string first = get<0>(t); // Access first element int second = get<1>(t); // Access second element double third = get<2>(t); // Access third element Best Practices Use the Right Container : Choose based on your access patterns and required operations. Avoid Premature Optimization : Start with a straightforward solution, then optimize if needed. Range-based for Loop : Prefer range-based for loops for cleaner code. cpp for (const auto& elem : container) { // Use elem } Use auto for Iterator Types : Makes code more readable and maintainable. Leverage STL Algorithms : They're well-tested and often more efficient than manual implementations. Pass by Reference : For large containers, pass by reference to avoid copying. Reserve Vector Capacity : If you know the size in advance, use vector::reserve() to avoid reallocations. Use emplace_back() Instead of push_back() : For objects that require construction, emplace_back() constructs in-place.","title":"STL"},{"location":"cpp/stl/#c-standard-template-library-stl","text":"The C++ STL is a powerful collection of template classes and functions providing common data structures and algorithms.","title":"C++ Standard Template Library (STL)"},{"location":"cpp/stl/#containers","text":"","title":"Containers"},{"location":"cpp/stl/#sequence-containers","text":"","title":"Sequence Containers"},{"location":"cpp/stl/#vector","text":"Dynamic array with automatic resizing. #include <vector> vector<int> vec; // Empty vector vector<int> vec = {1, 2, 3, 4}; // Initialization with values vector<int> vec(10, 0); // Vector of size 10 with all values as 0 // Common operations vec.push_back(5); // Add element at the end vec.pop_back(); // Remove last element vec.size(); // Get size vec.empty(); // Check if empty vec.clear(); // Remove all elements vec.resize(5); // Resize vector vec[0]; // Access element (no bounds checking) vec.at(0); // Access element (with bounds checking) vec.front(); // Access first element vec.back(); // Access last element Time Complexity: - Access: O(1) - Insert/Erase at end: O(1) amortized - Insert/Erase at arbitrary position: O(n)","title":"vector"},{"location":"cpp/stl/#deque","text":"Double-ended queue supporting fast insertion and deletion at both ends. #include <deque> deque<int> dq; // Empty deque deque<int> dq = {1, 2, 3, 4}; // Initialization with values // Common operations dq.push_back(5); // Add element at the end dq.push_front(0); // Add element at the beginning dq.pop_back(); // Remove last element dq.pop_front(); // Remove first element dq.size(); // Get size dq.empty(); // Check if empty dq.clear(); // Remove all elements dq[0]; // Access element (no bounds checking) dq.at(0); // Access element (with bounds checking) dq.front(); // Access first element dq.back(); // Access last element Time Complexity: - Access: O(1) - Insert/Erase at beginning/end: O(1) amortized - Insert/Erase at arbitrary position: O(n)","title":"deque"},{"location":"cpp/stl/#list","text":"Doubly-linked list. #include <list> list<int> lst; // Empty list list<int> lst = {1, 2, 3, 4}; // Initialization with values // Common operations lst.push_back(5); // Add element at the end lst.push_front(0); // Add element at the beginning lst.pop_back(); // Remove last element lst.pop_front(); // Remove first element lst.size(); // Get size lst.empty(); // Check if empty lst.clear(); // Remove all elements auto it = lst.begin(); // Iterator to first element lst.insert(it, 10); // Insert 10 before position of iterator lst.erase(it); // Erase element at iterator lst.front(); // Access first element lst.back(); // Access last element lst.sort(); // Sort the list lst.reverse(); // Reverse the list lst.merge(list2); // Merge two sorted lists lst.splice(it, list2); // Insert list2 at position it Time Complexity: - Access: O(n) - Insert/Erase with known position: O(1) - Search: O(n)","title":"list"},{"location":"cpp/stl/#forward_list","text":"Singly-linked list. #include <forward_list> forward_list<int> fl; // Empty forward_list forward_list<int> fl = {1, 2, 3};// Initialization with values // Common operations fl.push_front(0); // Add element at the beginning fl.pop_front(); // Remove first element fl.empty(); // Check if empty fl.clear(); // Remove all elements auto it = fl.begin(); // Iterator to first element auto it_before = fl.before_begin(); // Iterator before first element fl.insert_after(it, 10); // Insert 10 after position of iterator fl.erase_after(it); // Erase element after iterator fl.front(); // Access first element fl.sort(); // Sort the forward_list fl.reverse(); // Reverse the forward_list Time Complexity: - Access: O(n) - Insert/Erase with known position: O(1) - Search: O(n)","title":"forward_list"},{"location":"cpp/stl/#array","text":"Fixed-size array. #include <array> array<int, 5> arr; // Uninitialized array of size 5 array<int, 5> arr = {1, 2, 3, 4, 5}; // Initialization with values // Common operations arr.size(); // Get size arr.empty(); // Check if empty arr.fill(0); // Fill with 0s arr[0]; // Access element (no bounds checking) arr.at(0); // Access element (with bounds checking) arr.front(); // Access first element arr.back(); // Access last element Time Complexity: - Access: O(1) - Insert/Erase: Not supported (fixed size)","title":"array"},{"location":"cpp/stl/#associative-containers","text":"","title":"Associative Containers"},{"location":"cpp/stl/#set","text":"Collection of unique keys, sorted by keys. #include <set> set<int> s; // Empty set set<int> s = {1, 2, 3, 4}; // Initialization with values // Common operations s.insert(5); // Insert element s.erase(3); // Remove element with value 3 s.size(); // Get size s.empty(); // Check if empty s.clear(); // Remove all elements s.find(2); // Find element with value 2 s.count(2); // Count elements with value 2 (0 or 1) s.lower_bound(3); // Iterator to first element >= 3 s.upper_bound(3); // Iterator to first element > 3 Time Complexity: - Insert/Erase/Find: O(log n)","title":"set"},{"location":"cpp/stl/#multiset","text":"Collection of keys, sorted by keys (allows duplicates). #include <set> multiset<int> ms; // Empty multiset multiset<int> ms = {1, 2, 2, 3}; // Initialization with values // Common operations (similar to set) ms.insert(5); // Insert element ms.erase(3); // Remove all elements with value 3 auto it = ms.find(2); // Find first element with value 2 ms.erase(it); // Remove specific occurrence of 2 ms.count(2); // Count elements with value 2 Time Complexity: - Insert/Erase/Find: O(log n)","title":"multiset"},{"location":"cpp/stl/#map","text":"Collection of key-value pairs, sorted by keys, keys are unique. #include <map> map<string, int> mp; // Empty map {% raw %} map<string, int> mp = {{\"apple\", 5}, {\"banana\", 3}}; // Initialization with values {% endraw %} // Common operations mp[\"orange\"] = 2; // Insert or update key-value pair mp.insert({\"pear\", 4}); // Insert key-value pair mp.insert(make_pair(\"grape\", 6));// Another way to insert mp.erase(\"apple\"); // Remove element with key \"apple\" mp.size(); // Get size mp.empty(); // Check if empty mp.clear(); // Remove all elements mp.find(\"banana\"); // Find element with key \"banana\" mp.count(\"banana\"); // Count elements with key \"banana\" (0 or 1) Time Complexity: - Insert/Erase/Find: O(log n)","title":"map"},{"location":"cpp/stl/#multimap","text":"Collection of key-value pairs, sorted by keys (allows duplicate keys). #include <map> multimap<string, int> mm; // Empty multimap mm.insert({\"apple\", 5}); // Insert key-value pair mm.insert({\"apple\", 3}); // Insert another with same key Time Complexity: - Insert/Erase/Find: O(log n)","title":"multimap"},{"location":"cpp/stl/#unordered-associative-containers","text":"","title":"Unordered Associative Containers"},{"location":"cpp/stl/#unordered_set","text":"Collection of unique keys, hashed by keys. #include <unordered_set> unordered_set<int> us; // Empty unordered_set unordered_set<int> us = {1, 2, 3, 4}; // Initialization with values // Common operations (similar to set, but unordered) us.insert(5); // Insert element us.erase(3); // Remove element with value 3 us.find(2); // Find element with value 2 us.count(2); // Count elements with value 2 (0 or 1) Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case","title":"unordered_set"},{"location":"cpp/stl/#unordered_multiset","text":"Collection of keys, hashed by keys (allows duplicates). #include <unordered_set> unordered_multiset<int> ums; // Empty unordered_multiset ums.insert(2); // Insert element ums.insert(2); // Insert duplicate Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case","title":"unordered_multiset"},{"location":"cpp/stl/#unordered_map","text":"Collection of key-value pairs, hashed by keys, keys are unique. #include <unordered_map> unordered_map<string, int> um; // Empty unordered_map um[\"apple\"] = 5; // Insert or update key-value pair um.insert({\"banana\", 3}); // Insert key-value pair Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case","title":"unordered_map"},{"location":"cpp/stl/#unordered_multimap","text":"Collection of key-value pairs, hashed by keys (allows duplicate keys). #include <unordered_map> unordered_multimap<string, int> umm; // Empty unordered_multimap umm.insert({\"apple\", 5}); // Insert key-value pair umm.insert({\"apple\", 3}); // Insert another with same key Time Complexity: - Insert/Erase/Find: O(1) average, O(n) worst case","title":"unordered_multimap"},{"location":"cpp/stl/#container-adaptors","text":"","title":"Container Adaptors"},{"location":"cpp/stl/#stack","text":"LIFO (Last In, First Out) data structure. #include <stack> stack<int> stk; // Empty stack stk.push(1); // Add element to top stk.push(2); // Add element to top int top = stk.top(); // Access top element (2) stk.pop(); // Remove top element stk.size(); // Get size stk.empty(); // Check if empty Time Complexity: - Push/Pop/Top: O(1)","title":"stack"},{"location":"cpp/stl/#queue","text":"FIFO (First In, First Out) data structure. #include <queue> queue<int> q; // Empty queue q.push(1); // Add element to back q.push(2); // Add element to back int front = q.front(); // Access front element (1) int back = q.back(); // Access back element (2) q.pop(); // Remove front element q.size(); // Get size q.empty(); // Check if empty Time Complexity: - Push/Pop/Front/Back: O(1)","title":"queue"},{"location":"cpp/stl/#priority_queue","text":"Provides constant time lookup of the largest (by default) element. #include <queue> // Max heap (default) priority_queue<int> pq; // Empty priority queue pq.push(3); // Add element pq.push(5); // Add element pq.push(1); // Add element int top = pq.top(); // Access largest element (5) pq.pop(); // Remove largest element pq.size(); // Get size pq.empty(); // Check if empty // Min heap priority_queue<int, vector<int>, greater<int>> min_pq; min_pq.push(3); // Add element min_pq.push(5); // Add element min_pq.push(1); // Add element int min_top = min_pq.top(); // Access smallest element (1) Time Complexity: - Push/Pop: O(log n) - Top: O(1)","title":"priority_queue"},{"location":"cpp/stl/#algorithms","text":"STL provides various algorithms for common operations on containers. #include <algorithm> vector<int> v = {5, 2, 8, 1, 3}; // Sorting sort(v.begin(), v.end()); // Sort in ascending order sort(v.begin(), v.end(), greater<int>()); // Sort in descending order // Binary search (on sorted range) binary_search(v.begin(), v.end(), 3); // Returns true if 3 is in vector lower_bound(v.begin(), v.end(), 3); // Iterator to first element >= 3 upper_bound(v.begin(), v.end(), 3); // Iterator to first element > 3 // Min/Max *min_element(v.begin(), v.end()); // Smallest element *max_element(v.begin(), v.end()); // Largest element // Finding find(v.begin(), v.end(), 3); // Iterator to first occurrence of 3 count(v.begin(), v.end(), 3); // Count occurrences of 3 // Manipulation reverse(v.begin(), v.end()); // Reverse the vector rotate(v.begin(), v.begin() + 2, v.end()); // Rotate vector left by 2 positions random_shuffle(v.begin(), v.end()); // Randomly shuffle elements // Heap operations make_heap(v.begin(), v.end()); // Convert range to a heap push_heap(v.begin(), v.end()); // Add element to heap pop_heap(v.begin(), v.end()); // Move largest element to end and reconstitute heap // Numeric #include <numeric> accumulate(v.begin(), v.end(), 0); // Sum of elements (starting with 0) partial_sum(v.begin(), v.end(), result.begin()); // Partial sums","title":"Algorithms"},{"location":"cpp/stl/#iterators","text":"Iterators are used to access and traverse container elements. vector<int> v = {1, 2, 3, 4, 5}; // Types of iterators auto it = v.begin(); // Regular iterator auto rit = v.rbegin(); // Reverse iterator auto cit = v.cbegin(); // Constant iterator auto crit = v.crbegin(); // Constant reverse iterator // Iterator operations it++; // Move to next element it--; // Move to previous element it += 2; // Move forward by 2 (random access) *it; // Access element it = v.end(); // Iterator to one past the last element","title":"Iterators"},{"location":"cpp/stl/#utility-classes","text":"","title":"Utility Classes"},{"location":"cpp/stl/#pair","text":"Holds two values of possibly different types. #include <utility> pair<string, int> p(\"apple\", 5); // Create pair auto p = make_pair(\"apple\", 5); // Alternative creation string first = p.first; // Access first element int second = p.second; // Access second element","title":"pair"},{"location":"cpp/stl/#tuple","text":"Holds a fixed-size collection of elements of different types. #include <tuple> tuple<string, int, double> t(\"apple\", 5, 3.14); // Create tuple auto t = make_tuple(\"apple\", 5, 3.14); // Alternative creation string first = get<0>(t); // Access first element int second = get<1>(t); // Access second element double third = get<2>(t); // Access third element","title":"tuple"},{"location":"cpp/stl/#best-practices","text":"Use the Right Container : Choose based on your access patterns and required operations. Avoid Premature Optimization : Start with a straightforward solution, then optimize if needed. Range-based for Loop : Prefer range-based for loops for cleaner code. cpp for (const auto& elem : container) { // Use elem } Use auto for Iterator Types : Makes code more readable and maintainable. Leverage STL Algorithms : They're well-tested and often more efficient than manual implementations. Pass by Reference : For large containers, pass by reference to avoid copying. Reserve Vector Capacity : If you know the size in advance, use vector::reserve() to avoid reallocations. Use emplace_back() Instead of push_back() : For objects that require construction, emplace_back() constructs in-place.","title":"Best Practices"},{"location":"oop/cpp/concepts/","text":"Concepts Four Pillars of OOP Encapsulation Inheritance Polymorphism Abstraction Encapsulation Encapsulation is the bundling of data and methods that operate on that data within a single unit (class). class BankAccount { private: // Private fields - encapsulated std::string accountNumber; double balance; public: // Public methods to access and modify the fields in a controlled way std::string getAccountNumber() const { return accountNumber; } double getBalance() const { return balance; } void deposit(double amount) { if (amount > 0) { balance += amount; } } bool withdraw(double amount) { if (amount > 0 && balance >= amount) { balance -= amount; return true; } return false; } }; Inheritance Inheritance establishes an \"is-a\" relationship between classes. // Base class class Shape { protected: std::string color; public: Shape(const std::string& color) : color(color) { } // Virtual destructor for proper cleanup in derived classes virtual ~Shape() = default; std::string getColor() const { return color; } virtual double calculateArea() const { return 0.0; // Default implementation } }; // Derived class class Circle : public Shape { private: double radius; public: Circle(const std::string& color, double radius) : Shape(color), radius(radius) { } double calculateArea() const override { return M_PI * radius * radius; } }; Polymorphism Polymorphism allows objects of different types to be treated as objects of a common type. Method Overriding (Runtime Polymorphism / Dynamic Dispatch) Method Overloading (Compile-time Polymorphism) class Rectangle : public Shape { private: double width; double height; public: Rectangle(const std::string& color, double width, double height) : Shape(color), width(width), height(height) { } double calculateArea() const override { return width * height; } }; class ShapeProcessor { public: void printArea(const Shape& shape) { // Works with any Shape subclass due to polymorphism std::cout << \"Area: \" << shape.calculateArea() << std::endl; } }; int main() { ShapeProcessor processor; // Different objects, same method call Circle circle(\"red\", 5.0); Rectangle rectangle(\"blue\", 4.0, 6.0); processor.printArea(circle); processor.printArea(rectangle); return 0; } Abstraction Abstraction means focusing on essential qualities rather than the specific details. // Abstract class class DatabaseConnection { public: // Virtual destructor for proper cleanup in derived classes virtual ~DatabaseConnection() = default; // Pure virtual functions (abstract methods) virtual void connect() = 0; virtual void disconnect() = 0; virtual void executeQuery(const std::string& query) = 0; // Concrete method in abstract class void printConnectionStatus() { std::cout << \"Checking connection status...\" << std::endl; } }; // Concrete implementation class MySQLConnection : public DatabaseConnection { public: void connect() override { std::cout << \"Connecting to MySQL database...\" << std::endl; } void disconnect() override { std::cout << \"Disconnecting from MySQL database...\" << std::endl; } void executeQuery(const std::string& query) override { std::cout << \"Executing query in MySQL: \" << query << std::endl; } }; Interfaces vs Abstract Classes When to Use Interfaces: When unrelated classes need to implement the same behavior When to Use Abstract Classes: When you want to provide a common base implementation When you need to define non-public members When you want to maintain state across related classes~~","title":"Concepts"},{"location":"oop/cpp/concepts/#concepts","text":"Four Pillars of OOP Encapsulation Inheritance Polymorphism Abstraction Encapsulation Encapsulation is the bundling of data and methods that operate on that data within a single unit (class). class BankAccount { private: // Private fields - encapsulated std::string accountNumber; double balance; public: // Public methods to access and modify the fields in a controlled way std::string getAccountNumber() const { return accountNumber; } double getBalance() const { return balance; } void deposit(double amount) { if (amount > 0) { balance += amount; } } bool withdraw(double amount) { if (amount > 0 && balance >= amount) { balance -= amount; return true; } return false; } }; Inheritance Inheritance establishes an \"is-a\" relationship between classes. // Base class class Shape { protected: std::string color; public: Shape(const std::string& color) : color(color) { } // Virtual destructor for proper cleanup in derived classes virtual ~Shape() = default; std::string getColor() const { return color; } virtual double calculateArea() const { return 0.0; // Default implementation } }; // Derived class class Circle : public Shape { private: double radius; public: Circle(const std::string& color, double radius) : Shape(color), radius(radius) { } double calculateArea() const override { return M_PI * radius * radius; } }; Polymorphism Polymorphism allows objects of different types to be treated as objects of a common type. Method Overriding (Runtime Polymorphism / Dynamic Dispatch) Method Overloading (Compile-time Polymorphism) class Rectangle : public Shape { private: double width; double height; public: Rectangle(const std::string& color, double width, double height) : Shape(color), width(width), height(height) { } double calculateArea() const override { return width * height; } }; class ShapeProcessor { public: void printArea(const Shape& shape) { // Works with any Shape subclass due to polymorphism std::cout << \"Area: \" << shape.calculateArea() << std::endl; } }; int main() { ShapeProcessor processor; // Different objects, same method call Circle circle(\"red\", 5.0); Rectangle rectangle(\"blue\", 4.0, 6.0); processor.printArea(circle); processor.printArea(rectangle); return 0; } Abstraction Abstraction means focusing on essential qualities rather than the specific details. // Abstract class class DatabaseConnection { public: // Virtual destructor for proper cleanup in derived classes virtual ~DatabaseConnection() = default; // Pure virtual functions (abstract methods) virtual void connect() = 0; virtual void disconnect() = 0; virtual void executeQuery(const std::string& query) = 0; // Concrete method in abstract class void printConnectionStatus() { std::cout << \"Checking connection status...\" << std::endl; } }; // Concrete implementation class MySQLConnection : public DatabaseConnection { public: void connect() override { std::cout << \"Connecting to MySQL database...\" << std::endl; } void disconnect() override { std::cout << \"Disconnecting from MySQL database...\" << std::endl; } void executeQuery(const std::string& query) override { std::cout << \"Executing query in MySQL: \" << query << std::endl; } }; Interfaces vs Abstract Classes When to Use Interfaces: When unrelated classes need to implement the same behavior When to Use Abstract Classes: When you want to provide a common base implementation When you need to define non-public members When you want to maintain state across related classes~~","title":"Concepts"},{"location":"oop/cpp/design-patterns/","text":"Design Patterns in C++ Creational Patterns Singleton Pattern Ensures a class has only one instance and provides a global point of access to it. #include <iostream> #include <string> class DatabaseConnection { private: // Private constructor prevents instantiation DatabaseConnection() { // Initialize connection } // Delete copy constructor and assignment operator DatabaseConnection(const DatabaseConnection&) = delete; DatabaseConnection& operator=(const DatabaseConnection&) = delete; public: // Thread-safe in C++11 and later due to magic statics static DatabaseConnection& getInstance() { static DatabaseConnection instance; return instance; } void query(const std::string& sql) { // Execute query std::cout << \"Executing query: \" << sql << std::endl; } }; // Usage int main() { DatabaseConnection& connection = DatabaseConnection::getInstance(); connection.query(\"SELECT * FROM users\"); return 0; } Factory Method Pattern Defines an interface for creating an object, but lets subclasses decide which class to instantiate. #include <iostream> #include <memory> // Product interface class Vehicle { public: virtual ~Vehicle() = default; virtual void drive() = 0; }; // Concrete products class Car : public Vehicle { public: void drive() override { std::cout << \"Driving a car\" << std::endl; } }; class Truck : public Vehicle { public: void drive() override { std::cout << \"Driving a truck\" << std::endl; } }; // Creator class VehicleFactory { public: virtual ~VehicleFactory() = default; virtual Vehicle& createVehicle() = 0; void deliverVehicle() { Vehicle& vehicle = createVehicle(); std::cout << \"Delivering the vehicle...\" << std::endl; vehicle.drive(); } }; // Concrete creators using static storage class CarFactory : public VehicleFactory { private: Car car; public: Vehicle& createVehicle() override { return car; } }; class TruckFactory : public VehicleFactory { private: Truck truck; public: Vehicle& createVehicle() override { return truck; } }; int main() { CarFactory carFactory; carFactory.deliverVehicle(); TruckFactory truckFactory; truckFactory.deliverVehicle(); return 0; } Builder Pattern Separates the construction of a complex object from its representation. #include <iostream> #include <string> class Computer { private: std::string cpu; std::string ram; std::string storage; std::string gpu; std::string motherboard; public: // Make Builder a friend to access private fields friend class ComputerBuilder; void display() const { std::cout << \"Computer Specs:\\n\" << \"CPU: \" << cpu << \"\\n\" << \"RAM: \" << ram << \"\\n\" << \"Storage: \" << storage << \"\\n\" << \"GPU: \" << gpu << \"\\n\" << \"Motherboard: \" << motherboard << std::endl; } }; class ComputerBuilder { private: Computer computer; public: ComputerBuilder& cpu(const std::string& cpu) { computer.cpu = cpu; return *this; } ComputerBuilder& ram(const std::string& ram) { computer.ram = ram; return *this; } ComputerBuilder& storage(const std::string& storage) { computer.storage = storage; return *this; } ComputerBuilder& gpu(const std::string& gpu) { computer.gpu = gpu; return *this; } ComputerBuilder& motherboard(const std::string& motherboard) { computer.motherboard = motherboard; return *this; } Computer build() { return computer; } }; // Usage int main() { Computer computer = ComputerBuilder() .cpu(\"Intel i7\") .ram(\"16GB\") .storage(\"1TB SSD\") .gpu(\"NVIDIA RTX 3080\") .motherboard(\"ASUS ROG\") .build(); computer.display(); return 0; } Structural Patterns Adapter Pattern Allows incompatible interfaces to work together. #include <iostream> #include <string> // OldPaymentGateway (Adaptee) class OldPaymentGateway { public: void makePayment(const std::string& accountNumber, double amount) { std::cout << \"Old Gateway: Processing payment of $\" << amount << \" for account \" << accountNumber << std::endl; } }; // NewPaymentProcessor (Target Interface) class NewPaymentProcessor { public: virtual ~NewPaymentProcessor() = default; virtual void processPayment(const std::string& creditCardNumber, const std::string& expiryDate, const std::string& cvv, double amount) = 0; }; // PaymentAdapter (Adapter) class PaymentAdapter : public NewPaymentProcessor { private: OldPaymentGateway& oldGateway; public: PaymentAdapter(OldPaymentGateway& gateway) : oldGateway(gateway) {} void processPayment(const std::string& creditCardNumber, const std::string& expiryDate, const std::string& cvv, double amount) override { // Adapt: Here we might simplify and just use creditCardNumber as account for the old system std::cout << \"Adapter: Translating new payment request for old gateway...\" << std::endl; oldGateway.makePayment(creditCardNumber, amount); // Delegates to the old system } }; // Client code int main() { OldPaymentGateway oldGateway; PaymentAdapter adaptedProcessor(oldGateway); // Client code uses the NewPaymentProcessor interface adaptedProcessor.processPayment(\"1234-5678-9012-3456\", \"12/25\", \"123\", 100.00); return 0; } Decorator Pattern Attaches additional responsibilities to an object dynamically. #include <iostream> #include <string> // Component interface class Coffee { public: virtual ~Coffee() = default; virtual double getCost() const = 0; virtual std::string getDescription() const = 0; }; // Concrete component class SimpleCoffee : public Coffee { public: double getCost() const override { return 2.0; } std::string getDescription() const override { return \"Simple coffee\"; } }; // Decorator class CoffeeDecorator : public Coffee { protected: const Coffee& decoratedCoffee; public: CoffeeDecorator(const Coffee& coffee) : decoratedCoffee(coffee) {} double getCost() const override { return decoratedCoffee.getCost(); } std::string getDescription() const override { return decoratedCoffee.getDescription(); } }; // Concrete decorators class MilkDecorator : public CoffeeDecorator { public: MilkDecorator(const Coffee& coffee) : CoffeeDecorator(coffee) {} double getCost() const override { return CoffeeDecorator::getCost() + 0.5; } std::string getDescription() const override { return CoffeeDecorator::getDescription() + \", with milk\"; } }; class SugarDecorator : public CoffeeDecorator { public: SugarDecorator(const Coffee& coffee) : CoffeeDecorator(coffee) {} double getCost() const override { return CoffeeDecorator::getCost() + 0.2; } std::string getDescription() const override { return CoffeeDecorator::getDescription() + \", with sugar\"; } }; // Note: This is a limited version of the decorator pattern without dynamic lifetime. // Real use case might require allocations which would involve pointers. int main() { // Create base component SimpleCoffee simpleCoffee; // Stack allocated decorators MilkDecorator coffeeWithMilk(simpleCoffee); SugarDecorator sweetMilkCoffee(coffeeWithMilk); std::cout << \"Description: \" << sweetMilkCoffee.getDescription() << std::endl; std::cout << \"Cost: $\" << sweetMilkCoffee.getCost() << std::endl; return 0; } Behavioral Patterns Observer Pattern Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified. #include <iostream> #include <string> #include <vector> #include <algorithm> // Forward declaration class NewsAgency; // Observer interface class Observer { public: virtual ~Observer() = default; virtual void update(const std::string& message) = 0; virtual void registerWith(NewsAgency& agency) = 0; virtual void unregisterFrom(NewsAgency& agency) = 0; }; // Subject class NewsAgency { private: std::vector<Observer*> observers; std::string news; public: void addObserver(Observer* observer) { observers.push_back(observer); } void removeObserver(Observer* observer) { observers.erase( std::remove(observers.begin(), observers.end(), observer), observers.end() ); } void setNews(const std::string& news) { this->news = news; notifyObservers(); } private: void notifyObservers() { for (Observer* observer : observers) { observer->update(news); } } }; // Concrete observer class NewsSubscriber : public Observer { private: std::string name; public: NewsSubscriber(const std::string& name) : name(name) {} void update(const std::string& message) override { std::cout << name << \" received news: \" << message << std::endl; } void registerWith(NewsAgency& agency) override { agency.addObserver(this); } void unregisterFrom(NewsAgency& agency) override { agency.removeObserver(this); } }; int main() { NewsAgency agency; // Create subscribers NewsSubscriber subscriber1(\"John\"); NewsSubscriber subscriber2(\"Jane\"); // Register observers subscriber1.registerWith(agency); subscriber2.registerWith(agency); // Set news agency.setNews(\"Breaking News: C++ 23 standard released!\"); // Unregister an observer subscriber1.unregisterFrom(agency); // Set more news agency.setNews(\"Update: New features in C++ 23 explained.\"); return 0; } Strategy Pattern Defines a family of algorithms, encapsulates each one, and makes them interchangeable. #include <iostream> #include <string> // Strategy interface class PaymentStrategy { public: virtual ~PaymentStrategy() = default; virtual void pay(int amount) = 0; }; // Concrete strategies class CreditCardStrategy : public PaymentStrategy { private: std::string name; std::string cardNumber; std::string cvv; std::string dateOfExpiry; public: CreditCardStrategy(const std::string& name, const std::string& cardNumber, const std::string& cvv, const std::string& dateOfExpiry) : name(name), cardNumber(cardNumber), cvv(cvv), dateOfExpiry(dateOfExpiry) {} void pay(int amount) override { std::cout << amount << \" paid with credit card\" << std::endl; } }; class PayPalStrategy : public PaymentStrategy { private: std::string email; std::string password; public: PayPalStrategy(const std::string& email, const std::string& password) : email(email), password(password) {} void pay(int amount) override { std::cout << amount << \" paid using PayPal\" << std::endl; } }; // Context class ShoppingCart { private: PaymentStrategy* paymentStrategy = nullptr; public: // Using reference to strategy, not taking ownership void setPaymentStrategy(PaymentStrategy& strategy) { paymentStrategy = &strategy; } void checkout(int amount) { if (paymentStrategy) { paymentStrategy->pay(amount); } else { std::cout << \"No payment strategy set!\" << std::endl; } } }; int main() { ShoppingCart cart; // Create strategies on the stack CreditCardStrategy creditCard(\"John Doe\", \"1234567890123456\", \"123\", \"12/25\"); PayPalStrategy payPal(\"john@example.com\", \"password123\"); // Use credit card cart.setPaymentStrategy(creditCard); cart.checkout(100); // Switch to PayPal cart.setPaymentStrategy(payPal); cart.checkout(200); return 0; }","title":"Design Patterns"},{"location":"oop/cpp/design-patterns/#design-patterns-in-c","text":"","title":"Design Patterns in C++"},{"location":"oop/cpp/design-patterns/#creational-patterns","text":"Singleton Pattern Ensures a class has only one instance and provides a global point of access to it. #include <iostream> #include <string> class DatabaseConnection { private: // Private constructor prevents instantiation DatabaseConnection() { // Initialize connection } // Delete copy constructor and assignment operator DatabaseConnection(const DatabaseConnection&) = delete; DatabaseConnection& operator=(const DatabaseConnection&) = delete; public: // Thread-safe in C++11 and later due to magic statics static DatabaseConnection& getInstance() { static DatabaseConnection instance; return instance; } void query(const std::string& sql) { // Execute query std::cout << \"Executing query: \" << sql << std::endl; } }; // Usage int main() { DatabaseConnection& connection = DatabaseConnection::getInstance(); connection.query(\"SELECT * FROM users\"); return 0; } Factory Method Pattern Defines an interface for creating an object, but lets subclasses decide which class to instantiate. #include <iostream> #include <memory> // Product interface class Vehicle { public: virtual ~Vehicle() = default; virtual void drive() = 0; }; // Concrete products class Car : public Vehicle { public: void drive() override { std::cout << \"Driving a car\" << std::endl; } }; class Truck : public Vehicle { public: void drive() override { std::cout << \"Driving a truck\" << std::endl; } }; // Creator class VehicleFactory { public: virtual ~VehicleFactory() = default; virtual Vehicle& createVehicle() = 0; void deliverVehicle() { Vehicle& vehicle = createVehicle(); std::cout << \"Delivering the vehicle...\" << std::endl; vehicle.drive(); } }; // Concrete creators using static storage class CarFactory : public VehicleFactory { private: Car car; public: Vehicle& createVehicle() override { return car; } }; class TruckFactory : public VehicleFactory { private: Truck truck; public: Vehicle& createVehicle() override { return truck; } }; int main() { CarFactory carFactory; carFactory.deliverVehicle(); TruckFactory truckFactory; truckFactory.deliverVehicle(); return 0; } Builder Pattern Separates the construction of a complex object from its representation. #include <iostream> #include <string> class Computer { private: std::string cpu; std::string ram; std::string storage; std::string gpu; std::string motherboard; public: // Make Builder a friend to access private fields friend class ComputerBuilder; void display() const { std::cout << \"Computer Specs:\\n\" << \"CPU: \" << cpu << \"\\n\" << \"RAM: \" << ram << \"\\n\" << \"Storage: \" << storage << \"\\n\" << \"GPU: \" << gpu << \"\\n\" << \"Motherboard: \" << motherboard << std::endl; } }; class ComputerBuilder { private: Computer computer; public: ComputerBuilder& cpu(const std::string& cpu) { computer.cpu = cpu; return *this; } ComputerBuilder& ram(const std::string& ram) { computer.ram = ram; return *this; } ComputerBuilder& storage(const std::string& storage) { computer.storage = storage; return *this; } ComputerBuilder& gpu(const std::string& gpu) { computer.gpu = gpu; return *this; } ComputerBuilder& motherboard(const std::string& motherboard) { computer.motherboard = motherboard; return *this; } Computer build() { return computer; } }; // Usage int main() { Computer computer = ComputerBuilder() .cpu(\"Intel i7\") .ram(\"16GB\") .storage(\"1TB SSD\") .gpu(\"NVIDIA RTX 3080\") .motherboard(\"ASUS ROG\") .build(); computer.display(); return 0; }","title":"Creational Patterns"},{"location":"oop/cpp/design-patterns/#structural-patterns","text":"Adapter Pattern Allows incompatible interfaces to work together. #include <iostream> #include <string> // OldPaymentGateway (Adaptee) class OldPaymentGateway { public: void makePayment(const std::string& accountNumber, double amount) { std::cout << \"Old Gateway: Processing payment of $\" << amount << \" for account \" << accountNumber << std::endl; } }; // NewPaymentProcessor (Target Interface) class NewPaymentProcessor { public: virtual ~NewPaymentProcessor() = default; virtual void processPayment(const std::string& creditCardNumber, const std::string& expiryDate, const std::string& cvv, double amount) = 0; }; // PaymentAdapter (Adapter) class PaymentAdapter : public NewPaymentProcessor { private: OldPaymentGateway& oldGateway; public: PaymentAdapter(OldPaymentGateway& gateway) : oldGateway(gateway) {} void processPayment(const std::string& creditCardNumber, const std::string& expiryDate, const std::string& cvv, double amount) override { // Adapt: Here we might simplify and just use creditCardNumber as account for the old system std::cout << \"Adapter: Translating new payment request for old gateway...\" << std::endl; oldGateway.makePayment(creditCardNumber, amount); // Delegates to the old system } }; // Client code int main() { OldPaymentGateway oldGateway; PaymentAdapter adaptedProcessor(oldGateway); // Client code uses the NewPaymentProcessor interface adaptedProcessor.processPayment(\"1234-5678-9012-3456\", \"12/25\", \"123\", 100.00); return 0; } Decorator Pattern Attaches additional responsibilities to an object dynamically. #include <iostream> #include <string> // Component interface class Coffee { public: virtual ~Coffee() = default; virtual double getCost() const = 0; virtual std::string getDescription() const = 0; }; // Concrete component class SimpleCoffee : public Coffee { public: double getCost() const override { return 2.0; } std::string getDescription() const override { return \"Simple coffee\"; } }; // Decorator class CoffeeDecorator : public Coffee { protected: const Coffee& decoratedCoffee; public: CoffeeDecorator(const Coffee& coffee) : decoratedCoffee(coffee) {} double getCost() const override { return decoratedCoffee.getCost(); } std::string getDescription() const override { return decoratedCoffee.getDescription(); } }; // Concrete decorators class MilkDecorator : public CoffeeDecorator { public: MilkDecorator(const Coffee& coffee) : CoffeeDecorator(coffee) {} double getCost() const override { return CoffeeDecorator::getCost() + 0.5; } std::string getDescription() const override { return CoffeeDecorator::getDescription() + \", with milk\"; } }; class SugarDecorator : public CoffeeDecorator { public: SugarDecorator(const Coffee& coffee) : CoffeeDecorator(coffee) {} double getCost() const override { return CoffeeDecorator::getCost() + 0.2; } std::string getDescription() const override { return CoffeeDecorator::getDescription() + \", with sugar\"; } }; // Note: This is a limited version of the decorator pattern without dynamic lifetime. // Real use case might require allocations which would involve pointers. int main() { // Create base component SimpleCoffee simpleCoffee; // Stack allocated decorators MilkDecorator coffeeWithMilk(simpleCoffee); SugarDecorator sweetMilkCoffee(coffeeWithMilk); std::cout << \"Description: \" << sweetMilkCoffee.getDescription() << std::endl; std::cout << \"Cost: $\" << sweetMilkCoffee.getCost() << std::endl; return 0; }","title":"Structural Patterns"},{"location":"oop/cpp/design-patterns/#behavioral-patterns","text":"Observer Pattern Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified. #include <iostream> #include <string> #include <vector> #include <algorithm> // Forward declaration class NewsAgency; // Observer interface class Observer { public: virtual ~Observer() = default; virtual void update(const std::string& message) = 0; virtual void registerWith(NewsAgency& agency) = 0; virtual void unregisterFrom(NewsAgency& agency) = 0; }; // Subject class NewsAgency { private: std::vector<Observer*> observers; std::string news; public: void addObserver(Observer* observer) { observers.push_back(observer); } void removeObserver(Observer* observer) { observers.erase( std::remove(observers.begin(), observers.end(), observer), observers.end() ); } void setNews(const std::string& news) { this->news = news; notifyObservers(); } private: void notifyObservers() { for (Observer* observer : observers) { observer->update(news); } } }; // Concrete observer class NewsSubscriber : public Observer { private: std::string name; public: NewsSubscriber(const std::string& name) : name(name) {} void update(const std::string& message) override { std::cout << name << \" received news: \" << message << std::endl; } void registerWith(NewsAgency& agency) override { agency.addObserver(this); } void unregisterFrom(NewsAgency& agency) override { agency.removeObserver(this); } }; int main() { NewsAgency agency; // Create subscribers NewsSubscriber subscriber1(\"John\"); NewsSubscriber subscriber2(\"Jane\"); // Register observers subscriber1.registerWith(agency); subscriber2.registerWith(agency); // Set news agency.setNews(\"Breaking News: C++ 23 standard released!\"); // Unregister an observer subscriber1.unregisterFrom(agency); // Set more news agency.setNews(\"Update: New features in C++ 23 explained.\"); return 0; } Strategy Pattern Defines a family of algorithms, encapsulates each one, and makes them interchangeable. #include <iostream> #include <string> // Strategy interface class PaymentStrategy { public: virtual ~PaymentStrategy() = default; virtual void pay(int amount) = 0; }; // Concrete strategies class CreditCardStrategy : public PaymentStrategy { private: std::string name; std::string cardNumber; std::string cvv; std::string dateOfExpiry; public: CreditCardStrategy(const std::string& name, const std::string& cardNumber, const std::string& cvv, const std::string& dateOfExpiry) : name(name), cardNumber(cardNumber), cvv(cvv), dateOfExpiry(dateOfExpiry) {} void pay(int amount) override { std::cout << amount << \" paid with credit card\" << std::endl; } }; class PayPalStrategy : public PaymentStrategy { private: std::string email; std::string password; public: PayPalStrategy(const std::string& email, const std::string& password) : email(email), password(password) {} void pay(int amount) override { std::cout << amount << \" paid using PayPal\" << std::endl; } }; // Context class ShoppingCart { private: PaymentStrategy* paymentStrategy = nullptr; public: // Using reference to strategy, not taking ownership void setPaymentStrategy(PaymentStrategy& strategy) { paymentStrategy = &strategy; } void checkout(int amount) { if (paymentStrategy) { paymentStrategy->pay(amount); } else { std::cout << \"No payment strategy set!\" << std::endl; } } }; int main() { ShoppingCart cart; // Create strategies on the stack CreditCardStrategy creditCard(\"John Doe\", \"1234567890123456\", \"123\", \"12/25\"); PayPalStrategy payPal(\"john@example.com\", \"password123\"); // Use credit card cart.setPaymentStrategy(creditCard); cart.checkout(100); // Switch to PayPal cart.setPaymentStrategy(payPal); cart.checkout(200); return 0; }","title":"Behavioral Patterns"},{"location":"oop/cpp/solid-principles/","text":"Solid Principles in C++ SOLID is an acronym that stands for five design principles: Single Responsibility Principle (SRP) : A class should have only one reason to change, meaning that a class should only have one job or responsibility. Open/Closed Principle (OCP) : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Liskov Substitution Principle (LSP) : Subtypes must be substitutable for their base types. Interface Segregation Principle (ISP) : Clients should not be forced to depend on interfaces they do not use. Dependency Inversion Principle (DIP) : High-level modules should not depend on low-level modules. Both should depend on abstractions. Single Responsibility Principle (SRP) Principle : A class should have only one reason to change, meaning it should have only one job or responsibility. Bad Example : class Employee { private: std::string name; std::string id; public: // Employee data methods std::string getName() const { return name; } void setName(const std::string& name) { this->name = name; } // Database Operations void saveToDatabase() { // Database code here } // Report generation void generateReport() { // Report generation code here } }; Good Example : // Employee class only manages employee data class Employee { private: std::string name; std::string id; public: // Employee data methods std::string getName() const { return name; } void setName(const std::string& name) { this->name = name; } }; // Separate class for database operations class EmployeeRepository { public: void save(const Employee& employee) { // Database code here } }; // Separate class for reporting class EmployeeReportGenerator { public: void generateReport(const Employee& employee) { // Report generation code } }; Open/Closed Principle (OCP) Principle : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Bad Example : class PaymentProcessor { public: void processPayment(const std::string& paymentType, double amount) { if (paymentType == \"credit_card\") { // Process credit card payment } else if (paymentType == \"paypal\") { // Process PayPal payment } else if (paymentType == \"bitcoin\") { // Process Bitcoin payment } // Need to modify this class when adding new payment types } }; Good Example : // Interface (abstract class in C++) class PaymentMethod { public: virtual ~PaymentMethod() = default; virtual void processPayment(double amount) = 0; }; // Implementations class CreditCardPayment : public PaymentMethod { public: void processPayment(double amount) override { // Process credit card payment } }; class PayPalPayment : public PaymentMethod { public: void processPayment(double amount) override { // Process PayPal payment } }; class BitcoinPayment : public PaymentMethod { public: void processPayment(double amount) override { // Process Bitcoin payment } }; // Client code - closed for modification class PaymentProcessor { public: void processPayment(PaymentMethod& paymentMethod, double amount) { paymentMethod.processPayment(amount); } }; Liskov Substitution Principle (LSP) Principle : Subtypes must be substitutable for their base types without altering the correctness of the program. Bad Example : // BAD: Ostrich cannot fly, violates the \"Bird can fly\" expectation class Bird { public: virtual ~Bird() = default; virtual void fly() { std::cout << \"Bird is flying\" << std::endl; } }; class Sparrow : public Bird { // Sparrow can fly, consistent with Bird }; class Ostrich : public Bird { public: void fly() override { // Ostriches cannot fly. This breaks the expectation. throw std::runtime_error(\"Ostrich cannot fly!\"); // Or: std::cout << \"Ostrich cannot fly\" << std::endl; // Still problematic } }; // Client code // void makeBirdFly(Bird& bird) { // bird.fly(); // This will crash if 'bird' is an Ostrich // } Good Example : // GOOD: Separate flying behavior class Flyable { public: virtual ~Flyable() = default; virtual void fly() = 0; }; // Abstract base class for birds class Bird { public: virtual ~Bird() = default; virtual void makeSound() = 0; void eat() { std::cout << \"Bird is eating.\" << std::endl; } }; class Sparrow : public Bird, public Flyable { // Sparrow IS-A Bird and IS Flyable public: void makeSound() override { std::cout << \"Chirp\" << std::endl; } void fly() override { std::cout << \"Sparrow is flying high.\" << std::endl; } }; class Ostrich : public Bird { // Ostrich IS-A Bird, but NOT Flyable public: void makeSound() override { std::cout << \"Boom\" << std::endl; } // No fly() method, or a run() method specific to Ostrich void run() { std::cout << \"Ostrich is running fast.\" << std::endl; } }; class Penguin : public Bird { // Penguin is a bird but doesn't fly public: void makeSound() override { std::cout << \"Squawk\" << std::endl; } void swim() { std::cout << \"Penguin is swimming.\" << std::endl; } }; Interface Segregation Principle (ISP) Principle : Clients should not be forced to depend on interfaces they do not use. Bad Example : // Fat interface class Worker { public: virtual ~Worker() = default; virtual void work() = 0; virtual void eat() = 0; virtual void sleep() = 0; }; // Problem: Robot can't eat or sleep class Robot : public Worker { public: void work() override { // Working } void eat() override { // Robot can't eat, but forced to implement throw std::runtime_error(\"Operation not supported\"); } void sleep() override { // Robot can't sleep, but forced to implement throw std::runtime_error(\"Operation not supported\"); } }; Good Example : // Segregated interfaces class Workable { public: virtual ~Workable() = default; virtual void work() = 0; }; class Eatable { public: virtual ~Eatable() = default; virtual void eat() = 0; }; class Sleepable { public: virtual ~Sleepable() = default; virtual void sleep() = 0; }; // Human implements all interfaces class Human : public Workable, public Eatable, public Sleepable { public: void work() override { // Human working } void eat() override { // Human eating } void sleep() override { // Human sleeping } }; // Robot only implements what it needs class Robot : public Workable { public: void work() override { // Robot working } }; Dependency Inversion Principle (DIP) Principle : High-level modules should not depend on low-level modules. Both should depend on abstractions. Bad Example : // Low-level module class MySQLDatabase { public: void insert(const std::string& data) { // Insert data to MySQL } }; // High-level module depends on low-level module class UserService { private: MySQLDatabase database; public: UserService() { // Hard dependency } void addUser(const std::string& userData) { database.insert(userData); } }; Good Example : // Abstraction class Database { public: virtual ~Database() = default; virtual void insert(const std::string& data) = 0; }; // Low-level module implements abstraction class MySQLDatabase : public Database { public: void insert(const std::string& data) override { // Insert data to MySQL } }; // Alternative implementation class MongoDatabase : public Database { public: void insert(const std::string& data) override { // Insert data to MongoDB } }; // High-level module depends on abstraction class UserService { private: Database& database; public: // Dependency injection UserService(Database& database) : database(database) { } void addUser(const std::string& userData) { database.insert(userData); } };","title":"Solid Principles"},{"location":"oop/cpp/solid-principles/#solid-principles-in-c","text":"SOLID is an acronym that stands for five design principles: Single Responsibility Principle (SRP) : A class should have only one reason to change, meaning that a class should only have one job or responsibility. Open/Closed Principle (OCP) : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Liskov Substitution Principle (LSP) : Subtypes must be substitutable for their base types. Interface Segregation Principle (ISP) : Clients should not be forced to depend on interfaces they do not use. Dependency Inversion Principle (DIP) : High-level modules should not depend on low-level modules. Both should depend on abstractions.","title":"Solid Principles in C++"},{"location":"oop/cpp/solid-principles/#single-responsibility-principle-srp","text":"Principle : A class should have only one reason to change, meaning it should have only one job or responsibility. Bad Example : class Employee { private: std::string name; std::string id; public: // Employee data methods std::string getName() const { return name; } void setName(const std::string& name) { this->name = name; } // Database Operations void saveToDatabase() { // Database code here } // Report generation void generateReport() { // Report generation code here } }; Good Example : // Employee class only manages employee data class Employee { private: std::string name; std::string id; public: // Employee data methods std::string getName() const { return name; } void setName(const std::string& name) { this->name = name; } }; // Separate class for database operations class EmployeeRepository { public: void save(const Employee& employee) { // Database code here } }; // Separate class for reporting class EmployeeReportGenerator { public: void generateReport(const Employee& employee) { // Report generation code } };","title":"Single Responsibility Principle (SRP)"},{"location":"oop/cpp/solid-principles/#openclosed-principle-ocp","text":"Principle : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Bad Example : class PaymentProcessor { public: void processPayment(const std::string& paymentType, double amount) { if (paymentType == \"credit_card\") { // Process credit card payment } else if (paymentType == \"paypal\") { // Process PayPal payment } else if (paymentType == \"bitcoin\") { // Process Bitcoin payment } // Need to modify this class when adding new payment types } }; Good Example : // Interface (abstract class in C++) class PaymentMethod { public: virtual ~PaymentMethod() = default; virtual void processPayment(double amount) = 0; }; // Implementations class CreditCardPayment : public PaymentMethod { public: void processPayment(double amount) override { // Process credit card payment } }; class PayPalPayment : public PaymentMethod { public: void processPayment(double amount) override { // Process PayPal payment } }; class BitcoinPayment : public PaymentMethod { public: void processPayment(double amount) override { // Process Bitcoin payment } }; // Client code - closed for modification class PaymentProcessor { public: void processPayment(PaymentMethod& paymentMethod, double amount) { paymentMethod.processPayment(amount); } };","title":"Open/Closed Principle (OCP)"},{"location":"oop/cpp/solid-principles/#liskov-substitution-principle-lsp","text":"Principle : Subtypes must be substitutable for their base types without altering the correctness of the program. Bad Example : // BAD: Ostrich cannot fly, violates the \"Bird can fly\" expectation class Bird { public: virtual ~Bird() = default; virtual void fly() { std::cout << \"Bird is flying\" << std::endl; } }; class Sparrow : public Bird { // Sparrow can fly, consistent with Bird }; class Ostrich : public Bird { public: void fly() override { // Ostriches cannot fly. This breaks the expectation. throw std::runtime_error(\"Ostrich cannot fly!\"); // Or: std::cout << \"Ostrich cannot fly\" << std::endl; // Still problematic } }; // Client code // void makeBirdFly(Bird& bird) { // bird.fly(); // This will crash if 'bird' is an Ostrich // } Good Example : // GOOD: Separate flying behavior class Flyable { public: virtual ~Flyable() = default; virtual void fly() = 0; }; // Abstract base class for birds class Bird { public: virtual ~Bird() = default; virtual void makeSound() = 0; void eat() { std::cout << \"Bird is eating.\" << std::endl; } }; class Sparrow : public Bird, public Flyable { // Sparrow IS-A Bird and IS Flyable public: void makeSound() override { std::cout << \"Chirp\" << std::endl; } void fly() override { std::cout << \"Sparrow is flying high.\" << std::endl; } }; class Ostrich : public Bird { // Ostrich IS-A Bird, but NOT Flyable public: void makeSound() override { std::cout << \"Boom\" << std::endl; } // No fly() method, or a run() method specific to Ostrich void run() { std::cout << \"Ostrich is running fast.\" << std::endl; } }; class Penguin : public Bird { // Penguin is a bird but doesn't fly public: void makeSound() override { std::cout << \"Squawk\" << std::endl; } void swim() { std::cout << \"Penguin is swimming.\" << std::endl; } };","title":"Liskov Substitution Principle (LSP)"},{"location":"oop/cpp/solid-principles/#interface-segregation-principle-isp","text":"Principle : Clients should not be forced to depend on interfaces they do not use. Bad Example : // Fat interface class Worker { public: virtual ~Worker() = default; virtual void work() = 0; virtual void eat() = 0; virtual void sleep() = 0; }; // Problem: Robot can't eat or sleep class Robot : public Worker { public: void work() override { // Working } void eat() override { // Robot can't eat, but forced to implement throw std::runtime_error(\"Operation not supported\"); } void sleep() override { // Robot can't sleep, but forced to implement throw std::runtime_error(\"Operation not supported\"); } }; Good Example : // Segregated interfaces class Workable { public: virtual ~Workable() = default; virtual void work() = 0; }; class Eatable { public: virtual ~Eatable() = default; virtual void eat() = 0; }; class Sleepable { public: virtual ~Sleepable() = default; virtual void sleep() = 0; }; // Human implements all interfaces class Human : public Workable, public Eatable, public Sleepable { public: void work() override { // Human working } void eat() override { // Human eating } void sleep() override { // Human sleeping } }; // Robot only implements what it needs class Robot : public Workable { public: void work() override { // Robot working } };","title":"Interface Segregation Principle (ISP)"},{"location":"oop/cpp/solid-principles/#dependency-inversion-principle-dip","text":"Principle : High-level modules should not depend on low-level modules. Both should depend on abstractions. Bad Example : // Low-level module class MySQLDatabase { public: void insert(const std::string& data) { // Insert data to MySQL } }; // High-level module depends on low-level module class UserService { private: MySQLDatabase database; public: UserService() { // Hard dependency } void addUser(const std::string& userData) { database.insert(userData); } }; Good Example : // Abstraction class Database { public: virtual ~Database() = default; virtual void insert(const std::string& data) = 0; }; // Low-level module implements abstraction class MySQLDatabase : public Database { public: void insert(const std::string& data) override { // Insert data to MySQL } }; // Alternative implementation class MongoDatabase : public Database { public: void insert(const std::string& data) override { // Insert data to MongoDB } }; // High-level module depends on abstraction class UserService { private: Database& database; public: // Dependency injection UserService(Database& database) : database(database) { } void addUser(const std::string& userData) { database.insert(userData); } };","title":"Dependency Inversion Principle (DIP)"},{"location":"oop/java/concepts/","text":"Concepts Four Pillars of OOP Encapsulation Inheritance Polymorphism Abstraction Encapsulation Encapsulation is the bundling of data and methods that operate on that data within a single unit (class). public class BankAccount { // Private fields - encapsulated private String accountNumber; private double balance; // Public methods to access and modify the fields in a controlled way public String getAccountNumber() { return accountNumber; } public double getBalance() { return balance; } public void deposit(double amount) { if (amount > 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount > 0 && balance >= amount) { balance -= amount; return true; } return false; } } Inheritance Inheritance establishes an \"is-a\" relationship between classes. // Base class public class Shape { protected String color; public Shape(String color) { this.color = color; } public String getColor() { return color; } public double calculateArea() { return 0.0; // Default implementation } } // Derived class public class Circle extends Shape { private double radius; public Circle(String color, double radius) { super(color); // Call to parent constructor this.radius = radius; } @Override public double calculateArea() { return Math.PI * radius * radius; } } Polymorphism Polymorphism allows objects of different types to be treated as objects of a common type. Method Overriding (Runtime Polymorphism / Dynamic Dispatch) Method Overloading (Compile-time Polymorphism) public class ShapeProcessor { public void printArea(Shape shape) { // Works with any Shape subclass due to polymorphism System.out.println(\"Area: \" + shape.calculateArea()); } public static void main(String[] args) { ShapeProcessor processor = new ShapeProcessor(); // Different objects, same method call processor.printArea(new Circle(\"red\", 5.0)); processor.printArea(new Rectangle(\"blue\", 4.0, 6.0)); } } Abstraction Abstraction means focusing on essential qualities rather than the specific details. // Abstract class public abstract class DatabaseConnection { public abstract void connect(); public abstract void disconnect(); public abstract void executeQuery(String query); // Concrete method in abstract class public void printConnectionStatus() { System.out.println(\"Checking connection status...\"); } } // Concrete implementation public class MySQLConnection extends DatabaseConnection { @Override public void connect() { System.out.println(\"Connecting to MySQL database...\"); } @Override public void disconnect() { System.out.println(\"Disconnecting from MySQL database...\"); } @Override public void executeQuery(String query) { System.out.println(\"Executing query in MySQL: \" + query); } } Interfaces vs Abstract Classes When to Use Interfaces: When unrelated classes need to implement the same behavior When to Use Abstract Classes: When you want to provide a common base implementation When you need to define non-public members When you want to maintain state across related classes","title":"Concepts"},{"location":"oop/java/concepts/#concepts","text":"Four Pillars of OOP Encapsulation Inheritance Polymorphism Abstraction Encapsulation Encapsulation is the bundling of data and methods that operate on that data within a single unit (class). public class BankAccount { // Private fields - encapsulated private String accountNumber; private double balance; // Public methods to access and modify the fields in a controlled way public String getAccountNumber() { return accountNumber; } public double getBalance() { return balance; } public void deposit(double amount) { if (amount > 0) { balance += amount; } } public boolean withdraw(double amount) { if (amount > 0 && balance >= amount) { balance -= amount; return true; } return false; } } Inheritance Inheritance establishes an \"is-a\" relationship between classes. // Base class public class Shape { protected String color; public Shape(String color) { this.color = color; } public String getColor() { return color; } public double calculateArea() { return 0.0; // Default implementation } } // Derived class public class Circle extends Shape { private double radius; public Circle(String color, double radius) { super(color); // Call to parent constructor this.radius = radius; } @Override public double calculateArea() { return Math.PI * radius * radius; } } Polymorphism Polymorphism allows objects of different types to be treated as objects of a common type. Method Overriding (Runtime Polymorphism / Dynamic Dispatch) Method Overloading (Compile-time Polymorphism) public class ShapeProcessor { public void printArea(Shape shape) { // Works with any Shape subclass due to polymorphism System.out.println(\"Area: \" + shape.calculateArea()); } public static void main(String[] args) { ShapeProcessor processor = new ShapeProcessor(); // Different objects, same method call processor.printArea(new Circle(\"red\", 5.0)); processor.printArea(new Rectangle(\"blue\", 4.0, 6.0)); } } Abstraction Abstraction means focusing on essential qualities rather than the specific details. // Abstract class public abstract class DatabaseConnection { public abstract void connect(); public abstract void disconnect(); public abstract void executeQuery(String query); // Concrete method in abstract class public void printConnectionStatus() { System.out.println(\"Checking connection status...\"); } } // Concrete implementation public class MySQLConnection extends DatabaseConnection { @Override public void connect() { System.out.println(\"Connecting to MySQL database...\"); } @Override public void disconnect() { System.out.println(\"Disconnecting from MySQL database...\"); } @Override public void executeQuery(String query) { System.out.println(\"Executing query in MySQL: \" + query); } } Interfaces vs Abstract Classes When to Use Interfaces: When unrelated classes need to implement the same behavior When to Use Abstract Classes: When you want to provide a common base implementation When you need to define non-public members When you want to maintain state across related classes","title":"Concepts"},{"location":"oop/java/design-patterns/","text":"Design Patterns in Java Creational Patterns Singleton Pattern Ensures a class has only one instance and provides a global point of access to it. public class DatabaseConnection { private static DatabaseConnection instance; // Private constructor prevents instantiation private DatabaseConnection() { // Initialize connection } // Thread-safe implementation public static synchronized DatabaseConnection getInstance() { if (instance == null) { instance = new DatabaseConnection(); } return instance; } public void query(String sql) { // Execute query } } // Usage DatabaseConnection connection = DatabaseConnection.getInstance(); connection.query(\"SELECT * FROM users\"); Factory Method Pattern Defines an interface for creating an object, but lets subclasses decide which class to instantiate. // Product interface public interface Vehicle { void drive(); } // Concrete products public class Car implements Vehicle { @Override public void drive() { System.out.println(\"Driving a car\"); } } public class Truck implements Vehicle { @Override public void drive() { System.out.println(\"Driving a truck\"); } } // Creator public abstract class VehicleFactory { public abstract Vehicle createVehicle(); public void deliverVehicle() { Vehicle vehicle = createVehicle(); System.out.println(\"Delivering the vehicle...\"); vehicle.drive(); } } // Concrete creators public class CarFactory extends VehicleFactory { @Override public Vehicle createVehicle() { return new Car(); } } public class TruckFactory extends VehicleFactory { @Override public Vehicle createVehicle() { return new Truck(); } } Builder Pattern Separates the construction of a complex object from its representation. public class Computer { private String cpu; private String ram; private String storage; private String gpu; private String motherboard; private Computer() {} public static class Builder { private Computer computer = new Computer(); public Builder cpu(String cpu) { computer.cpu = cpu; return this; } public Builder ram(String ram) { computer.ram = ram; return this; } public Builder storage(String storage) { computer.storage = storage; return this; } public Builder gpu(String gpu) { computer.gpu = gpu; return this; } public Builder motherboard(String motherboard) { computer.motherboard = motherboard; return this; } public Computer build() { return computer; } } } // Usage Computer computer = new Computer.Builder() .cpu(\"Intel i7\") .ram(\"16GB\") .storage(\"1TB SSD\") .gpu(\"NVIDIA RTX 3080\") .motherboard(\"ASUS ROG\") .build(); Structural Patterns Adapter Pattern Allows incompatible interfaces to work together. // OldPaymentGateway.java (Adaptee) class OldPaymentGateway { public void makePayment(String accountNumber, double amount) { System.out.println(\"Old Gateway: Processing payment of $\" + amount + \" for account \" + accountNumber); } } // NewPaymentProcessor.java (Target Interface) interface NewPaymentProcessor { void processPayment(String creditCardNumber, String expiryDate, String cvv, double amount); } // PaymentAdapter.java (Adapter) class PaymentAdapter implements NewPaymentProcessor { private OldPaymentGateway oldGateway; public PaymentAdapter(OldPaymentGateway oldGateway) { this.oldGateway = oldGateway; } @Override public void processPayment(String creditCardNumber, String expiryDate, String cvv, double amount) { // Adapt: Here we might simplify and just use creditCardNumber as account for the old system // In a real scenario, you'd map fields appropriately or throw an error if not possible. System.out.println(\"Adapter: Translating new payment request for old gateway...\"); oldGateway.makePayment(creditCardNumber, amount); // Delegates to the old system } } // Main.java (Client) public class Main { public static void main(String[] args) { OldPaymentGateway oldGateway = new OldPaymentGateway(); NewPaymentProcessor adaptedProcessor = new PaymentAdapter(oldGateway); // Client code uses the NewPaymentProcessor interface adaptedProcessor.processPayment(\"1234-5678-9012-3456\", \"12/25\", \"123\", 100.00); } } Decorator Pattern Attaches additional responsibilities to an object dynamically. // Component interface public interface Coffee { double getCost(); String getDescription(); } // Concrete component public class SimpleCoffee implements Coffee { @Override public double getCost() { return 2.0; } @Override public String getDescription() { return \"Simple coffee\"; } } // Decorator public abstract class CoffeeDecorator implements Coffee { protected Coffee decoratedCoffee; public CoffeeDecorator(Coffee coffee) { this.decoratedCoffee = coffee; } @Override public double getCost() { return decoratedCoffee.getCost(); } @Override public String getDescription() { return decoratedCoffee.getDescription(); } } // Concrete decorators public class MilkDecorator extends CoffeeDecorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public double getCost() { return super.getCost() + 0.5; } @Override public String getDescription() { return super.getDescription() + \", with milk\"; } } public class SugarDecorator extends CoffeeDecorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public double getCost() { return super.getCost() + 0.2; } @Override public String getDescription() { return super.getDescription() + \", with sugar\"; } } // Order a coffee with milk and sugar Coffee sweetMilkCoffee = new SugarDecorator(new MilkDecorator(new SimpleCoffee())); Behavioral Patterns Observer Pattern Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified. // Observer interface public interface Observer { void update(String message); } // Subject public class NewsAgency { private List<Observer> observers = new ArrayList<>(); private String news; public void addObserver(Observer observer) { observers.add(observer); } public void removeObserver(Observer observer) { observers.remove(observer); } public void setNews(String news) { this.news = news; notifyObservers(); } private void notifyObservers() { for (Observer observer : observers) { observer.update(news); } } } Strategy Pattern Defines a family of algorithms, encapsulates each one, and makes them interchangeable. // Strategy interface public interface PaymentStrategy { void pay(int amount); } // Concrete strategies public class CreditCardStrategy implements PaymentStrategy { private String name; private String cardNumber; private String cvv; private String dateOfExpiry; public CreditCardStrategy(String name, String cardNumber, String cvv, String dateOfExpiry) { this.name = name; this.cardNumber = cardNumber; this.cvv = cvv; this.dateOfExpiry = dateOfExpiry; } @Override public void pay(int amount) { System.out.println(amount + \" paid with credit card\"); } } public class PayPalStrategy implements PaymentStrategy { private String email; private String password; public PayPalStrategy(String email, String password) { this.email = email; this.password = password; } @Override public void pay(int amount) { System.out.println(amount + \" paid using PayPal\"); } } // Context public class ShoppingCart { private PaymentStrategy paymentStrategy; public void setPaymentStrategy(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void checkout(int amount) { paymentStrategy.pay(amount); } }","title":"Design Patterns"},{"location":"oop/java/design-patterns/#design-patterns-in-java","text":"","title":"Design Patterns in Java"},{"location":"oop/java/design-patterns/#creational-patterns","text":"Singleton Pattern Ensures a class has only one instance and provides a global point of access to it. public class DatabaseConnection { private static DatabaseConnection instance; // Private constructor prevents instantiation private DatabaseConnection() { // Initialize connection } // Thread-safe implementation public static synchronized DatabaseConnection getInstance() { if (instance == null) { instance = new DatabaseConnection(); } return instance; } public void query(String sql) { // Execute query } } // Usage DatabaseConnection connection = DatabaseConnection.getInstance(); connection.query(\"SELECT * FROM users\"); Factory Method Pattern Defines an interface for creating an object, but lets subclasses decide which class to instantiate. // Product interface public interface Vehicle { void drive(); } // Concrete products public class Car implements Vehicle { @Override public void drive() { System.out.println(\"Driving a car\"); } } public class Truck implements Vehicle { @Override public void drive() { System.out.println(\"Driving a truck\"); } } // Creator public abstract class VehicleFactory { public abstract Vehicle createVehicle(); public void deliverVehicle() { Vehicle vehicle = createVehicle(); System.out.println(\"Delivering the vehicle...\"); vehicle.drive(); } } // Concrete creators public class CarFactory extends VehicleFactory { @Override public Vehicle createVehicle() { return new Car(); } } public class TruckFactory extends VehicleFactory { @Override public Vehicle createVehicle() { return new Truck(); } } Builder Pattern Separates the construction of a complex object from its representation. public class Computer { private String cpu; private String ram; private String storage; private String gpu; private String motherboard; private Computer() {} public static class Builder { private Computer computer = new Computer(); public Builder cpu(String cpu) { computer.cpu = cpu; return this; } public Builder ram(String ram) { computer.ram = ram; return this; } public Builder storage(String storage) { computer.storage = storage; return this; } public Builder gpu(String gpu) { computer.gpu = gpu; return this; } public Builder motherboard(String motherboard) { computer.motherboard = motherboard; return this; } public Computer build() { return computer; } } } // Usage Computer computer = new Computer.Builder() .cpu(\"Intel i7\") .ram(\"16GB\") .storage(\"1TB SSD\") .gpu(\"NVIDIA RTX 3080\") .motherboard(\"ASUS ROG\") .build();","title":"Creational Patterns"},{"location":"oop/java/design-patterns/#structural-patterns","text":"Adapter Pattern Allows incompatible interfaces to work together. // OldPaymentGateway.java (Adaptee) class OldPaymentGateway { public void makePayment(String accountNumber, double amount) { System.out.println(\"Old Gateway: Processing payment of $\" + amount + \" for account \" + accountNumber); } } // NewPaymentProcessor.java (Target Interface) interface NewPaymentProcessor { void processPayment(String creditCardNumber, String expiryDate, String cvv, double amount); } // PaymentAdapter.java (Adapter) class PaymentAdapter implements NewPaymentProcessor { private OldPaymentGateway oldGateway; public PaymentAdapter(OldPaymentGateway oldGateway) { this.oldGateway = oldGateway; } @Override public void processPayment(String creditCardNumber, String expiryDate, String cvv, double amount) { // Adapt: Here we might simplify and just use creditCardNumber as account for the old system // In a real scenario, you'd map fields appropriately or throw an error if not possible. System.out.println(\"Adapter: Translating new payment request for old gateway...\"); oldGateway.makePayment(creditCardNumber, amount); // Delegates to the old system } } // Main.java (Client) public class Main { public static void main(String[] args) { OldPaymentGateway oldGateway = new OldPaymentGateway(); NewPaymentProcessor adaptedProcessor = new PaymentAdapter(oldGateway); // Client code uses the NewPaymentProcessor interface adaptedProcessor.processPayment(\"1234-5678-9012-3456\", \"12/25\", \"123\", 100.00); } } Decorator Pattern Attaches additional responsibilities to an object dynamically. // Component interface public interface Coffee { double getCost(); String getDescription(); } // Concrete component public class SimpleCoffee implements Coffee { @Override public double getCost() { return 2.0; } @Override public String getDescription() { return \"Simple coffee\"; } } // Decorator public abstract class CoffeeDecorator implements Coffee { protected Coffee decoratedCoffee; public CoffeeDecorator(Coffee coffee) { this.decoratedCoffee = coffee; } @Override public double getCost() { return decoratedCoffee.getCost(); } @Override public String getDescription() { return decoratedCoffee.getDescription(); } } // Concrete decorators public class MilkDecorator extends CoffeeDecorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public double getCost() { return super.getCost() + 0.5; } @Override public String getDescription() { return super.getDescription() + \", with milk\"; } } public class SugarDecorator extends CoffeeDecorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public double getCost() { return super.getCost() + 0.2; } @Override public String getDescription() { return super.getDescription() + \", with sugar\"; } } // Order a coffee with milk and sugar Coffee sweetMilkCoffee = new SugarDecorator(new MilkDecorator(new SimpleCoffee()));","title":"Structural Patterns"},{"location":"oop/java/design-patterns/#behavioral-patterns","text":"Observer Pattern Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified. // Observer interface public interface Observer { void update(String message); } // Subject public class NewsAgency { private List<Observer> observers = new ArrayList<>(); private String news; public void addObserver(Observer observer) { observers.add(observer); } public void removeObserver(Observer observer) { observers.remove(observer); } public void setNews(String news) { this.news = news; notifyObservers(); } private void notifyObservers() { for (Observer observer : observers) { observer.update(news); } } } Strategy Pattern Defines a family of algorithms, encapsulates each one, and makes them interchangeable. // Strategy interface public interface PaymentStrategy { void pay(int amount); } // Concrete strategies public class CreditCardStrategy implements PaymentStrategy { private String name; private String cardNumber; private String cvv; private String dateOfExpiry; public CreditCardStrategy(String name, String cardNumber, String cvv, String dateOfExpiry) { this.name = name; this.cardNumber = cardNumber; this.cvv = cvv; this.dateOfExpiry = dateOfExpiry; } @Override public void pay(int amount) { System.out.println(amount + \" paid with credit card\"); } } public class PayPalStrategy implements PaymentStrategy { private String email; private String password; public PayPalStrategy(String email, String password) { this.email = email; this.password = password; } @Override public void pay(int amount) { System.out.println(amount + \" paid using PayPal\"); } } // Context public class ShoppingCart { private PaymentStrategy paymentStrategy; public void setPaymentStrategy(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void checkout(int amount) { paymentStrategy.pay(amount); } }","title":"Behavioral Patterns"},{"location":"oop/java/solid-principles/","text":"Solid Principles in Java SOLID is an acronym that stands for five design principles: Single Responsibility Principle (SRP) : A class should have only one reason to change, meaning that a class should only have one job or responsibility. Open/Closed Principle (OCP) : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Liskov Substitution Principle (LSP) : Subtypes must be substitutable for their base types. Interface Segregation Principle (ISP) : Clients should not be forced to depend on interfaces they do not use. Dependency Inversion Principle (DIP) : High-level modules should not depend on low-level modules. Both should depend on abstractions. Single Responsibility Principle (SRP) Principle : A class should have only one reason to change, meaning it should have only one job or responsibility. Bad Example : public class Employee { private String name; private String id; // Employee data methods public String getName() { return name; } public void setName(String name) { this.name = name; } // Database Operations public void saveToDatabase() { // Database code here } // Report generation public void generateReport() { // Report generation code here } } Good Example : // Employee class only manages employee data public class Employee { private String name; private String id; // Employee data methods public String getName() { return name; } public void setName(String name) { this.name = name; } } // Separate class for database operations public class EmployeeRepository { public void save(Employee employee) { // Database code here } } // Separate class for reporting public class EmployeeReportGenerator { public void generateReport(Employee employee) { // Report generation code } } Open/Closed Principle (OCP) Principle : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Bad Example : public class PaymentProcessor { public void processPayment(String paymentType, double amount) { if (paymentType.equals(\"credit_card\")) { // Process credit card payment } else if (paymentType.equals(\"paypal\")) { // Process PayPal payment } else if (paymentType.equals(\"bitcoin\")) { // Process Bitcoin payment } // Need to modify this class when adding new payment types } } Good Example : // Interface public interface PaymentMethod { void processPayment(double amount); } // Implementations public class CreditCardPayment implements PaymentMethod { @Override public void processPayment(double amount) { // Process credit card payment } } public class PayPalPayment implements PaymentMethod { @Override public void processPayment(double amount) { // Process PayPal payment } } public class BitcoinPayment implements PaymentMethod { @Override public void processPayment(double amount) { // Process Bitcoin payment } } // Client code - closed for modification public class PaymentProcessor { public void processPayment(PaymentMethod paymentMethod, double amount) { paymentMethod.processPayment(amount); } } Liskov Substitution Principle (LSP) Principle : Subtypes must be substitutable for their base types without altering the correctness of the program. Bad Example : // BAD: Ostrich cannot fly, violates the \"Bird can fly\" expectation class Bird { public void fly() { System.out.println(\"Bird is flying\"); } } class Sparrow extends Bird { // Sparrow can fly, consistent with Bird } class Ostrich extends Bird { @Override public void fly() { // Ostriches cannot fly. This breaks the expectation. throw new UnsupportedOperationException(\"Ostrich cannot fly!\"); // Or: System.out.println(\"Ostrich cannot fly\"); // Still problematic } } // Client code // public void makeBirdFly(Bird bird) { // bird.fly(); // This will crash if 'bird' is an Ostrich // } Good Example : // GOOD: Separate flying behavior interface Flyable { void fly(); } abstract class Bird { // General bird properties abstract void makeSound(); public void eat() { System.out.println(\"Bird is eating.\"); } } class Sparrow extends Bird implements Flyable { // Sparrow IS-A Bird and IS Flyable @Override public void makeSound() { System.out.println(\"Chirp\"); } @Override public void fly() { System.out.println(\"Sparrow is flying high.\"); } } class Ostrich extends Bird { // Ostrich IS-A Bird, but NOT Flyable @Override public void makeSound() { System.out.println(\"Boom\"); } // No fly() method, or a run() method specific to Ostrich public void run() { System.out.println(\"Ostrich is running fast.\"); } } class Penguin extends Bird { // Penguin is a bird but doesn't fly @Override public void makeSound() { System.out.println(\"Squawk\"); } public void swim() { System.out.println(\"Penguin is swimming.\"); } } Interface Segregation Principle (ISP) Principle : Clients should not be forced to depend on interfaces they do not use. Bad Example : // Fat interface public interface Worker { void work(); void eat(); void sleep(); } // Problem: Robot can't eat or sleep public class Robot implements Worker { @Override public void work() { // Working } @Override public void eat() { // Robot can't eat, but forced to implement throw new UnsupportedOperationException(); } @Override public void sleep() { // Robot can't sleep, but forced to implement throw new UnsupportedOperationException(); } } Good Example : // Segregated interfaces public interface Workable { void work(); } public interface Eatable { void eat(); } public interface Sleepable { void sleep(); } // Human implements all interfaces public class Human implements Workable, Eatable, Sleepable { @Override public void work() { // Human working } @Override public void eat() { // Human eating } @Override public void sleep() { // Human sleeping } } // Robot only implements what it needs public class Robot implements Workable { @Override public void work() { // Robot working } } Dependency Inversion Principle (DIP) Principle : High-level modules should not depend on low-level modules. Both should depend on abstractions. Bad Example : // Low-level module public class MySQLDatabase { public void insert(String data) { // Insert data to MySQL } } // High-level module depends on low-level module public class UserService { private MySQLDatabase database; public UserService() { this.database = new MySQLDatabase(); // Hard dependency } public void addUser(String userData) { database.insert(userData); } } Good Example : // Abstraction public interface Database { void insert(String data); } // Low-level module implements abstraction public class MySQLDatabase implements Database { @Override public void insert(String data) { // Insert data to MySQL } } // Alternative implementation public class MongoDatabase implements Database { @Override public void insert(String data) { // Insert data to MongoDB } } // High-level module depends on abstraction public class UserService { private Database database; // Dependency injection public UserService(Database database) { this.database = database; } public void addUser(String userData) { database.insert(userData); } }","title":"Solid Principles"},{"location":"oop/java/solid-principles/#solid-principles-in-java","text":"SOLID is an acronym that stands for five design principles: Single Responsibility Principle (SRP) : A class should have only one reason to change, meaning that a class should only have one job or responsibility. Open/Closed Principle (OCP) : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Liskov Substitution Principle (LSP) : Subtypes must be substitutable for their base types. Interface Segregation Principle (ISP) : Clients should not be forced to depend on interfaces they do not use. Dependency Inversion Principle (DIP) : High-level modules should not depend on low-level modules. Both should depend on abstractions.","title":"Solid Principles in Java"},{"location":"oop/java/solid-principles/#single-responsibility-principle-srp","text":"Principle : A class should have only one reason to change, meaning it should have only one job or responsibility. Bad Example : public class Employee { private String name; private String id; // Employee data methods public String getName() { return name; } public void setName(String name) { this.name = name; } // Database Operations public void saveToDatabase() { // Database code here } // Report generation public void generateReport() { // Report generation code here } } Good Example : // Employee class only manages employee data public class Employee { private String name; private String id; // Employee data methods public String getName() { return name; } public void setName(String name) { this.name = name; } } // Separate class for database operations public class EmployeeRepository { public void save(Employee employee) { // Database code here } } // Separate class for reporting public class EmployeeReportGenerator { public void generateReport(Employee employee) { // Report generation code } }","title":"Single Responsibility Principle (SRP)"},{"location":"oop/java/solid-principles/#openclosed-principle-ocp","text":"Principle : Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. Bad Example : public class PaymentProcessor { public void processPayment(String paymentType, double amount) { if (paymentType.equals(\"credit_card\")) { // Process credit card payment } else if (paymentType.equals(\"paypal\")) { // Process PayPal payment } else if (paymentType.equals(\"bitcoin\")) { // Process Bitcoin payment } // Need to modify this class when adding new payment types } } Good Example : // Interface public interface PaymentMethod { void processPayment(double amount); } // Implementations public class CreditCardPayment implements PaymentMethod { @Override public void processPayment(double amount) { // Process credit card payment } } public class PayPalPayment implements PaymentMethod { @Override public void processPayment(double amount) { // Process PayPal payment } } public class BitcoinPayment implements PaymentMethod { @Override public void processPayment(double amount) { // Process Bitcoin payment } } // Client code - closed for modification public class PaymentProcessor { public void processPayment(PaymentMethod paymentMethod, double amount) { paymentMethod.processPayment(amount); } }","title":"Open/Closed Principle (OCP)"},{"location":"oop/java/solid-principles/#liskov-substitution-principle-lsp","text":"Principle : Subtypes must be substitutable for their base types without altering the correctness of the program. Bad Example : // BAD: Ostrich cannot fly, violates the \"Bird can fly\" expectation class Bird { public void fly() { System.out.println(\"Bird is flying\"); } } class Sparrow extends Bird { // Sparrow can fly, consistent with Bird } class Ostrich extends Bird { @Override public void fly() { // Ostriches cannot fly. This breaks the expectation. throw new UnsupportedOperationException(\"Ostrich cannot fly!\"); // Or: System.out.println(\"Ostrich cannot fly\"); // Still problematic } } // Client code // public void makeBirdFly(Bird bird) { // bird.fly(); // This will crash if 'bird' is an Ostrich // } Good Example : // GOOD: Separate flying behavior interface Flyable { void fly(); } abstract class Bird { // General bird properties abstract void makeSound(); public void eat() { System.out.println(\"Bird is eating.\"); } } class Sparrow extends Bird implements Flyable { // Sparrow IS-A Bird and IS Flyable @Override public void makeSound() { System.out.println(\"Chirp\"); } @Override public void fly() { System.out.println(\"Sparrow is flying high.\"); } } class Ostrich extends Bird { // Ostrich IS-A Bird, but NOT Flyable @Override public void makeSound() { System.out.println(\"Boom\"); } // No fly() method, or a run() method specific to Ostrich public void run() { System.out.println(\"Ostrich is running fast.\"); } } class Penguin extends Bird { // Penguin is a bird but doesn't fly @Override public void makeSound() { System.out.println(\"Squawk\"); } public void swim() { System.out.println(\"Penguin is swimming.\"); } }","title":"Liskov Substitution Principle (LSP)"},{"location":"oop/java/solid-principles/#interface-segregation-principle-isp","text":"Principle : Clients should not be forced to depend on interfaces they do not use. Bad Example : // Fat interface public interface Worker { void work(); void eat(); void sleep(); } // Problem: Robot can't eat or sleep public class Robot implements Worker { @Override public void work() { // Working } @Override public void eat() { // Robot can't eat, but forced to implement throw new UnsupportedOperationException(); } @Override public void sleep() { // Robot can't sleep, but forced to implement throw new UnsupportedOperationException(); } } Good Example : // Segregated interfaces public interface Workable { void work(); } public interface Eatable { void eat(); } public interface Sleepable { void sleep(); } // Human implements all interfaces public class Human implements Workable, Eatable, Sleepable { @Override public void work() { // Human working } @Override public void eat() { // Human eating } @Override public void sleep() { // Human sleeping } } // Robot only implements what it needs public class Robot implements Workable { @Override public void work() { // Robot working } }","title":"Interface Segregation Principle (ISP)"},{"location":"oop/java/solid-principles/#dependency-inversion-principle-dip","text":"Principle : High-level modules should not depend on low-level modules. Both should depend on abstractions. Bad Example : // Low-level module public class MySQLDatabase { public void insert(String data) { // Insert data to MySQL } } // High-level module depends on low-level module public class UserService { private MySQLDatabase database; public UserService() { this.database = new MySQLDatabase(); // Hard dependency } public void addUser(String userData) { database.insert(userData); } } Good Example : // Abstraction public interface Database { void insert(String data); } // Low-level module implements abstraction public class MySQLDatabase implements Database { @Override public void insert(String data) { // Insert data to MySQL } } // Alternative implementation public class MongoDatabase implements Database { @Override public void insert(String data) { // Insert data to MongoDB } } // High-level module depends on abstraction public class UserService { private Database database; // Dependency injection public UserService(Database database) { this.database = database; } public void addUser(String userData) { database.insert(userData); } }","title":"Dependency Inversion Principle (DIP)"},{"location":"problem-solving/backtracking/","text":"Backtracking Problems Subsets Given an integer array nums of unique elements, return all possible subsets. class Solution { public: void backtrack(int curIndex, vector<int>& subset, vector<vector<int>>& subsets, vector<int>& nums) { if (curIndex == nums.size()) { subsets.push_back(subset); return; } backtrack(curIndex+1, subset, subsets, nums); subset.push_back(nums[curIndex]); backtrack(curIndex+1, subset, subsets, nums); subset.pop_back(); } vector<vector<int>> subsets(vector<int>& nums) { vector<int> subset; vector<vector<int>> subsets; backtrack(0, subset, subsets, nums); return subsets; } }; Combination Sum Given an array of distinct integers and a target integer, return a list of all unique combinations where the chosen numbers sum to target. The same number may be chosen an unlimited number of times. Permutations Given an array of distinct integers, return all possible permutations. class Solution { public: void backtrack(vector<int>& cur, vector<vector<int>>& ans, vector<bool>& visited, vector<int>& nums) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i < nums.size(); i++) { if (!visited[i]) { cur.push_back(nums[i]); visited[i] = true; backtrack(cur, ans, visited, nums); cur.pop_back(); visited[i] = false; } } } vector<vector<int>> permute(vector<int>& nums) { vector<int> cur; vector<vector<int>> ans; vector<bool> visited(nums.size(), false); backtrack(cur, ans, visited, nums); return ans; } }; Words Search Given an m x n grid of characters and a string word, return true if word exists in the grid. class Solution { public: vector<int> dx = {-1, 1, 0, 0}; vector<int> dy = {0, 0, -1, 1}; bool backtrack(int x, int y, int wordPos, vector<vector<char>>& board, string& word) { if (wordPos == word.length()) return true; for (int i = 0; i < 4; i++) { int newX = x + dx[i]; int newY = y + dy[i]; if (newX >= 0 && newX < board.size() && newY >= 0 && newY < board[0].size() && board[newX][newY] == word[wordPos]) { board[newX][newY] = '#'; if (backtrack(newX, newY, wordPos+1, board, word)) return true; board[newX][newY] = word[wordPos]; } } return false; } bool exist(vector<vector<char>>& board, string word) { for (int i = 0; i < board.size(); i++) { for (int j = 0; j < board[0].size(); j++) { if (board[i][j] == word[0]) { board[i][j] = '#'; if (backtrack(i, j, 1, board, word)) return true; board[i][j] = word[0]; } } } return false; } }; N-Queens The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. class Solution { public: vector<string> createEmptyBoard(int n) { string emptyRow = \"\"; for (int col = 0; col < n; col++) emptyRow += '.'; vector<string> board; for (int row = 0; row < n; row++) board.push_back(emptyRow); return board; } void backtrack(int row, vector<string> &board, vector<vector<string>>& results, unordered_set<int>& cols, unordered_set<int>& diagonals, unordered_set<int>& antiDiagonals) { if (row == board.size()) { results.push_back(board); return; } for (int col = 0; col < board[0].size(); col++) { int curDiagonal = row - col; int curAntiDiagonal = row + col; if (cols.find(col) == cols.end() && diagonals.find(curDiagonal) == diagonals.end() && antiDiagonals.find(curAntiDiagonal) == antiDiagonals.end()) { cols.insert(col); diagonals.insert(curDiagonal); antiDiagonals.insert(curAntiDiagonal); board[row][col] = 'Q'; backtrack(row+1, board, results, cols, diagonals, antiDiagonals); cols.erase(col); diagonals.erase(curDiagonal); antiDiagonals.erase(curAntiDiagonal); board[row][col] = '.'; } } } vector<vector<string>> solveNQueens(int n) { vector<string> emptyBoard = createEmptyBoard(n); unordered_set<int> cols; unordered_set<int> diagonals; unordered_set<int> antiDiagonals; vector<vector<string>> results; backtrack(0, emptyBoard, results, cols, diagonals, antiDiagonals); return results; } };","title":"Backtracking"},{"location":"problem-solving/backtracking/#backtracking-problems","text":"Subsets Given an integer array nums of unique elements, return all possible subsets. class Solution { public: void backtrack(int curIndex, vector<int>& subset, vector<vector<int>>& subsets, vector<int>& nums) { if (curIndex == nums.size()) { subsets.push_back(subset); return; } backtrack(curIndex+1, subset, subsets, nums); subset.push_back(nums[curIndex]); backtrack(curIndex+1, subset, subsets, nums); subset.pop_back(); } vector<vector<int>> subsets(vector<int>& nums) { vector<int> subset; vector<vector<int>> subsets; backtrack(0, subset, subsets, nums); return subsets; } }; Combination Sum Given an array of distinct integers and a target integer, return a list of all unique combinations where the chosen numbers sum to target. The same number may be chosen an unlimited number of times. Permutations Given an array of distinct integers, return all possible permutations. class Solution { public: void backtrack(vector<int>& cur, vector<vector<int>>& ans, vector<bool>& visited, vector<int>& nums) { if (cur.size() == nums.size()) { ans.push_back(cur); return; } for (int i = 0; i < nums.size(); i++) { if (!visited[i]) { cur.push_back(nums[i]); visited[i] = true; backtrack(cur, ans, visited, nums); cur.pop_back(); visited[i] = false; } } } vector<vector<int>> permute(vector<int>& nums) { vector<int> cur; vector<vector<int>> ans; vector<bool> visited(nums.size(), false); backtrack(cur, ans, visited, nums); return ans; } }; Words Search Given an m x n grid of characters and a string word, return true if word exists in the grid. class Solution { public: vector<int> dx = {-1, 1, 0, 0}; vector<int> dy = {0, 0, -1, 1}; bool backtrack(int x, int y, int wordPos, vector<vector<char>>& board, string& word) { if (wordPos == word.length()) return true; for (int i = 0; i < 4; i++) { int newX = x + dx[i]; int newY = y + dy[i]; if (newX >= 0 && newX < board.size() && newY >= 0 && newY < board[0].size() && board[newX][newY] == word[wordPos]) { board[newX][newY] = '#'; if (backtrack(newX, newY, wordPos+1, board, word)) return true; board[newX][newY] = word[wordPos]; } } return false; } bool exist(vector<vector<char>>& board, string word) { for (int i = 0; i < board.size(); i++) { for (int j = 0; j < board[0].size(); j++) { if (board[i][j] == word[0]) { board[i][j] = '#'; if (backtrack(i, j, 1, board, word)) return true; board[i][j] = word[0]; } } } return false; } }; N-Queens The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. class Solution { public: vector<string> createEmptyBoard(int n) { string emptyRow = \"\"; for (int col = 0; col < n; col++) emptyRow += '.'; vector<string> board; for (int row = 0; row < n; row++) board.push_back(emptyRow); return board; } void backtrack(int row, vector<string> &board, vector<vector<string>>& results, unordered_set<int>& cols, unordered_set<int>& diagonals, unordered_set<int>& antiDiagonals) { if (row == board.size()) { results.push_back(board); return; } for (int col = 0; col < board[0].size(); col++) { int curDiagonal = row - col; int curAntiDiagonal = row + col; if (cols.find(col) == cols.end() && diagonals.find(curDiagonal) == diagonals.end() && antiDiagonals.find(curAntiDiagonal) == antiDiagonals.end()) { cols.insert(col); diagonals.insert(curDiagonal); antiDiagonals.insert(curAntiDiagonal); board[row][col] = 'Q'; backtrack(row+1, board, results, cols, diagonals, antiDiagonals); cols.erase(col); diagonals.erase(curDiagonal); antiDiagonals.erase(curAntiDiagonal); board[row][col] = '.'; } } } vector<vector<string>> solveNQueens(int n) { vector<string> emptyBoard = createEmptyBoard(n); unordered_set<int> cols; unordered_set<int> diagonals; unordered_set<int> antiDiagonals; vector<vector<string>> results; backtrack(0, emptyBoard, results, cols, diagonals, antiDiagonals); return results; } };","title":"Backtracking Problems"},{"location":"problem-solving/divide-and-conquer/","text":"Divide and Conquer Problems","title":"Divide and Conquer Problems"},{"location":"problem-solving/divide-and-conquer/#divide-and-conquer-problems","text":"","title":"Divide and Conquer Problems"},{"location":"problem-solving/greedy/","text":"Greedy Problems Find Subarray with Maximum Sum class Solution { public: int maxSubArray(vector<int>& nums) { int maxSubArray = nums[0]; int minPrefixSum = 0, curPrefixSum = 0; for (int num: nums) { curPrefixSum += num; maxSubArray = max(maxSubArray, curPrefixSum - minPrefixSum); minPrefixSum = min(minPrefixSum, curPrefixSum); } return maxSubArray; } }; Jump Game Given an integer array nums where you start at index 0 and nums[i] represents your maximum jump length at position i, return true if you can reach the last index, false otherwise. Jump Game II Given an integer array nums where you start at index 0 and nums[i] represents your maximum jump length at position i, return the minimum number of jumps required to reach the last index. Gas Station","title":"Greedy"},{"location":"problem-solving/greedy/#greedy-problems","text":"Find Subarray with Maximum Sum class Solution { public: int maxSubArray(vector<int>& nums) { int maxSubArray = nums[0]; int minPrefixSum = 0, curPrefixSum = 0; for (int num: nums) { curPrefixSum += num; maxSubArray = max(maxSubArray, curPrefixSum - minPrefixSum); minPrefixSum = min(minPrefixSum, curPrefixSum); } return maxSubArray; } }; Jump Game Given an integer array nums where you start at index 0 and nums[i] represents your maximum jump length at position i, return true if you can reach the last index, false otherwise. Jump Game II Given an integer array nums where you start at index 0 and nums[i] represents your maximum jump length at position i, return the minimum number of jumps required to reach the last index. Gas Station","title":"Greedy Problems"},{"location":"problem-solving/intervals/","text":"","title":"Intervals"},{"location":"problem-solving/sliding-window/","text":"","title":"Sliding window"},{"location":"problem-solving/two-pointers/","text":"Two Pointers Problems 3Sum Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0 Container With Most Water You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.","title":"Two Pointers Problems"},{"location":"problem-solving/two-pointers/#two-pointers-problems","text":"3Sum Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0 Container With Most Water You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.","title":"Two Pointers Problems"},{"location":"system-design/ad-click-aggregator/","text":"","title":"Ad Click Aggregator"},{"location":"system-design/dropbox/","text":"Design Dropbox Functional Requirements Users should be able to upload a file from any device Users should be able to download a file from any device Users can automatically sync files across devices Non Functional Requirements Availability > Consistency The system should support files as large as 50GB The system should make upload, download, and sync times as fast as possible (low latency) Core Entities File File Metadata User APIs // Upload a file POST /files Request: { File, FileMetadata } // Download a file GET /files/{fileId} -> File & FileMetadata // Sync a file GET /files/{fileId}/changes -> FileMetadata[] High Level Design Users should be able to upload a file from any device 1. Upload Metadata For the metadata, we can use a NoSQL database like DynamoDB. DynamoDB is a fully managed NoSQL database hosted by AWS. Our metadata is loosely structured, with few relations and the main query pattern being to fetch files by user. Our schema will be a simple document and can start with something like this: { \"id\": \"123\", \"name\": \"file.txt\", \"size\": 1000, \"mimeType\": \"text/plain\", \"uploadedBy\": \"user1\" } 2. Upload File Request a pre-signed URL from our backend (which itself gets the URL from the Blob Storage service like S3) and save the file metadata in our database with a status of \"uploading.\" Use the presigned URL to upload the file to Blob Storage directly from the client. This is via a PUT request directly to the presigned URL where the file is the body of the request. Once the file is uploaded, the Blob Storage service will send a notification to our backend using S3 Notifications. Our backend will then update the file metadata in our database with a status of \"uploaded\". Users should be able to download a file from any device Request a presigned download URL from our backend Use the presigned URL to download the file from the Blob Storage service directly to the client Users can automatically sync files across devices Local -> Remote Monitors the local Dropbox folder for changes using OS-specific file system events (like FileSystemWatcher on Windows or FSEvents on macOS) When it detects a change, it queues the modified file for upload locally It then uses our upload API to send the changes to the server along with updated metadata Conflicts are resolved using a \"last write wins\" strategy - meaning if two users edit the same file, the most recent edit will be the one that's saved Remote -> Local Polling: The client periodically asks the server \"has anything changed since my last sync?\" The server would query the DB to see if any files that this user is watching has a updatedAt timestamp that is newer than the last time they synced. Deep Dive How can you support large files? User should have: Progress Indicator: Users should be able to see the progress of their upload so that they know it's working and how long it will take. Resumable Uploads: Users should be able to pause and resume uploads. If they lose their internet connection or close the browser, they should be able to pick up where they left off Limitations of uploading a large file via single POST request: Timeouts: Web servers and clients typically have timeout settings to prevent indefinite waiting for a response. A single POST request for a 50GB file could easily exceed these timeouts. Browser and Server Limitation: Both browsers and web servers often impose limits on the size of a request payload. Network Interruptions: Large files are more susceptible to network interruptions. If a user is uploading a 50GB file and their internet connection drops, they will have to start the upload from scratch. User Experience: Users are effectively blind to the progress of their upload. They have no idea how long it will take or if it's even working. Chucking : To address these limitations, we can use a technique called \"chunking\" to break the file into smaller pieces and upload them one at a time (or in parallel, depending on network bandwidth). Chunking needs to be done on the client so that the file can be broken into pieces before it is sent to the server (or S3 in our case). how will we handle resumable uploads? We need to keep track of which chunks have been uploaded and which haven't. We can do this by saving the state of the upload in the database, specifically in our FileMetadata table. Let's update the FileMetadata schema to include a chunks field. { \"id\": \"123\", \"name\": \"file.txt\", \"size\": 1000, \"mimeType\": \"text/plain\", \"uploadedBy\": \"user1\", \"status\": \"uploading\", \"chunks\": [ { \"id\": \"chunk1\", \"status\": \"uploaded\" }, { \"id\": \"chunk2\", \"status\": \"uploading\" }, { \"id\": \"chunk3\", \"status\": \"not-uploaded\" } ] } How to uniquely identify a file / a chunk? When you try to resume an upload, the very first question that should be asked is: (1) Have I tried to upload this file before? and (2) If yes, which chunks have I already uploaded? To answer the first question, we cannot naively rely on the file name. A fingerprint is a mathematical calculation that generates a unique hash value based on the content of the file. This hash value, often created using cryptographic hash functions like SHA-256, serves as a robust and unique identifier for the file regardless of its name or the source of the upload. By computing this fingerprint, we can efficiently determine whether the file, or any portion of it, has been uploaded before. Complete Upload Process The client will chunk the file into 5-10Mb pieces and calculate a fingerprint for each chunk. It will also calculate a fingerprint for the entire file, this becomes the fileId. The client will send a GET request to fetch the FileMetadata for the file with the given fileId (fingerprint) in order to see if it already exists -- in which case, we can resume the upload. If the file does not exist, the client will POST a request to /files/presigned-url to get a presigned URL for the file. The backend will save the file metadata in the FileMetadata table with a status of \"uploading\" and the chunks array will be a list of the chunk fingerprints with a status of \"not-uploaded\". The client will then upload each chunk to S3 using the presigned URL. After each chunk is uploaded, S3 will send a message to our backend using S3 event notifications. Our backend will then update the chunks field in the FileMetadata table to mark the chunk as \"uploaded\". Once all chunks in our chunks array are marked as \"uploaded\", the backend will update the FileMetadata table to mark the file as \"uploaded\". How can we make uploads, downloads, and syncing as fast as possible? Compression How can you ensure file security? Encryption in Transit: HTTPS Encryption at Rest: S3 server-side encryption","title":"Dropbox"},{"location":"system-design/dropbox/#design-dropbox","text":"","title":"Design Dropbox"},{"location":"system-design/dropbox/#functional-requirements","text":"Users should be able to upload a file from any device Users should be able to download a file from any device Users can automatically sync files across devices","title":"Functional Requirements"},{"location":"system-design/dropbox/#non-functional-requirements","text":"Availability > Consistency The system should support files as large as 50GB The system should make upload, download, and sync times as fast as possible (low latency)","title":"Non Functional Requirements"},{"location":"system-design/dropbox/#core-entities","text":"File File Metadata User","title":"Core Entities"},{"location":"system-design/dropbox/#apis","text":"// Upload a file POST /files Request: { File, FileMetadata } // Download a file GET /files/{fileId} -> File & FileMetadata // Sync a file GET /files/{fileId}/changes -> FileMetadata[]","title":"APIs"},{"location":"system-design/dropbox/#high-level-design","text":"Users should be able to upload a file from any device 1. Upload Metadata For the metadata, we can use a NoSQL database like DynamoDB. DynamoDB is a fully managed NoSQL database hosted by AWS. Our metadata is loosely structured, with few relations and the main query pattern being to fetch files by user. Our schema will be a simple document and can start with something like this: { \"id\": \"123\", \"name\": \"file.txt\", \"size\": 1000, \"mimeType\": \"text/plain\", \"uploadedBy\": \"user1\" } 2. Upload File Request a pre-signed URL from our backend (which itself gets the URL from the Blob Storage service like S3) and save the file metadata in our database with a status of \"uploading.\" Use the presigned URL to upload the file to Blob Storage directly from the client. This is via a PUT request directly to the presigned URL where the file is the body of the request. Once the file is uploaded, the Blob Storage service will send a notification to our backend using S3 Notifications. Our backend will then update the file metadata in our database with a status of \"uploaded\". Users should be able to download a file from any device Request a presigned download URL from our backend Use the presigned URL to download the file from the Blob Storage service directly to the client Users can automatically sync files across devices Local -> Remote Monitors the local Dropbox folder for changes using OS-specific file system events (like FileSystemWatcher on Windows or FSEvents on macOS) When it detects a change, it queues the modified file for upload locally It then uses our upload API to send the changes to the server along with updated metadata Conflicts are resolved using a \"last write wins\" strategy - meaning if two users edit the same file, the most recent edit will be the one that's saved Remote -> Local Polling: The client periodically asks the server \"has anything changed since my last sync?\" The server would query the DB to see if any files that this user is watching has a updatedAt timestamp that is newer than the last time they synced.","title":"High Level Design"},{"location":"system-design/dropbox/#deep-dive","text":"How can you support large files? User should have: Progress Indicator: Users should be able to see the progress of their upload so that they know it's working and how long it will take. Resumable Uploads: Users should be able to pause and resume uploads. If they lose their internet connection or close the browser, they should be able to pick up where they left off Limitations of uploading a large file via single POST request: Timeouts: Web servers and clients typically have timeout settings to prevent indefinite waiting for a response. A single POST request for a 50GB file could easily exceed these timeouts. Browser and Server Limitation: Both browsers and web servers often impose limits on the size of a request payload. Network Interruptions: Large files are more susceptible to network interruptions. If a user is uploading a 50GB file and their internet connection drops, they will have to start the upload from scratch. User Experience: Users are effectively blind to the progress of their upload. They have no idea how long it will take or if it's even working. Chucking : To address these limitations, we can use a technique called \"chunking\" to break the file into smaller pieces and upload them one at a time (or in parallel, depending on network bandwidth). Chunking needs to be done on the client so that the file can be broken into pieces before it is sent to the server (or S3 in our case). how will we handle resumable uploads? We need to keep track of which chunks have been uploaded and which haven't. We can do this by saving the state of the upload in the database, specifically in our FileMetadata table. Let's update the FileMetadata schema to include a chunks field. { \"id\": \"123\", \"name\": \"file.txt\", \"size\": 1000, \"mimeType\": \"text/plain\", \"uploadedBy\": \"user1\", \"status\": \"uploading\", \"chunks\": [ { \"id\": \"chunk1\", \"status\": \"uploaded\" }, { \"id\": \"chunk2\", \"status\": \"uploading\" }, { \"id\": \"chunk3\", \"status\": \"not-uploaded\" } ] } How to uniquely identify a file / a chunk? When you try to resume an upload, the very first question that should be asked is: (1) Have I tried to upload this file before? and (2) If yes, which chunks have I already uploaded? To answer the first question, we cannot naively rely on the file name. A fingerprint is a mathematical calculation that generates a unique hash value based on the content of the file. This hash value, often created using cryptographic hash functions like SHA-256, serves as a robust and unique identifier for the file regardless of its name or the source of the upload. By computing this fingerprint, we can efficiently determine whether the file, or any portion of it, has been uploaded before. Complete Upload Process The client will chunk the file into 5-10Mb pieces and calculate a fingerprint for each chunk. It will also calculate a fingerprint for the entire file, this becomes the fileId. The client will send a GET request to fetch the FileMetadata for the file with the given fileId (fingerprint) in order to see if it already exists -- in which case, we can resume the upload. If the file does not exist, the client will POST a request to /files/presigned-url to get a presigned URL for the file. The backend will save the file metadata in the FileMetadata table with a status of \"uploading\" and the chunks array will be a list of the chunk fingerprints with a status of \"not-uploaded\". The client will then upload each chunk to S3 using the presigned URL. After each chunk is uploaded, S3 will send a message to our backend using S3 event notifications. Our backend will then update the chunks field in the FileMetadata table to mark the chunk as \"uploaded\". Once all chunks in our chunks array are marked as \"uploaded\", the backend will update the FileMetadata table to mark the file as \"uploaded\". How can we make uploads, downloads, and syncing as fast as possible? Compression How can you ensure file security? Encryption in Transit: HTTPS Encryption at Rest: S3 server-side encryption","title":"Deep Dive"},{"location":"system-design/live-comments/","text":"","title":"Live Comments"},{"location":"system-design/ticketmaster/","text":"","title":"Ticketmaster"},{"location":"system-design/tinder/","text":"Design Tinder Capacity Estimation Assumptions - Total Users: 100 million - DAU (Daily Active Users): 20 million - User activity: 10 swipes per user per day - User profile & preference size: 1 KB - Swipe data size: 100 bytes Storage Calculation - User profile & preferences: 100 million users * 1 KB = 100 GB - Daily swipes (30 days): 20 million users * 10 swipes/day * 30 days = 600 GB Bandwidth Calculation - Incoming Bandwidth (Swipes) = 20 million users * 10 swipes/day * 100 bytes / 10^5 seconds = 200 KB/s - Outgoing Bandwidth (1 profile viewed per swipe) = 20 million users * 10 swipes/day * 1 KB / 10^4 seconds = 2 MB/s QPS Calculation - Swipe QPS (Write operations) = 200 million swipes / day / 10^5 seconds - Profile View QPS (Read operations) =","title":"Tinder"},{"location":"system-design/tinder/#design-tinder","text":"","title":"Design Tinder"},{"location":"system-design/tinder/#capacity-estimation","text":"Assumptions - Total Users: 100 million - DAU (Daily Active Users): 20 million - User activity: 10 swipes per user per day - User profile & preference size: 1 KB - Swipe data size: 100 bytes Storage Calculation - User profile & preferences: 100 million users * 1 KB = 100 GB - Daily swipes (30 days): 20 million users * 10 swipes/day * 30 days = 600 GB Bandwidth Calculation - Incoming Bandwidth (Swipes) = 20 million users * 10 swipes/day * 100 bytes / 10^5 seconds = 200 KB/s - Outgoing Bandwidth (1 profile viewed per swipe) = 20 million users * 10 swipes/day * 1 KB / 10^4 seconds = 2 MB/s QPS Calculation - Swipe QPS (Write operations) = 200 million swipes / day / 10^5 seconds - Profile View QPS (Read operations) =","title":"Capacity Estimation"},{"location":"system-design/uber/","text":"","title":"Uber"},{"location":"system-design/url-shortener/","text":"Design URL Shortening Service Functional Requirements Users should be able to submit a long URL and receive a shortened URL. Optionally, users should be able to specify a custom alias for the shortened URL. Optionally, users should be able to specify an expiration date for the shortened URL. Users should be able to access the original URL using the shortened URL. Non Functional Requirements Ensure uniqueness for the shortened URLs. (No two long URLs should map to the same short URL.) Redirection should occur with minimal latency. Availability > Consistency Support 1B shortened URLs (in total) & 100M DAU Capacity Estimation Storage Estimation : Assume metadata entry for each URL is 500 bytes. Short URL -> 8 bytes Long URL -> 100 bytes Created At -> 8 bytes User ID -> 8 bytes TTL -> 8 bytes Total Storage = 500 bytes * 1B = 500 GB Traffic Estimation : Assume 100M DAU with 10 requests per user per day Total Requests = 100M * 10 = 1B requests per day Total Requests per second = 1B / 10^5 = 10k request / second Assume 1% of requests are for shortening URLs Total Shortening Requests = 10k * 0.01 = 100 requests / second Core Entities User Original URL Shortened URL APIs // Shorten a URL POST /urls { \"long_url\": \"https://www.example.com/some/very/long/url\", \"custom_alias\": \"optional_custom_alias\", \"expiration_date\": \"optional_expiration_date\" } -> { \"short_url\": \"http://short.ly/abc123\" } // Redirect to Original URL GET /{short_code} -> HTTP 302 Redirect to the original long URL High Level Design 1. Users should be able to submit a long URL and receive a shortened URL 2. Users should be able to access the original URL using the shortened URL HTTP Redirect Response 301 (Permanent Redirect) : This indicates that the resource has been permanently moved to the target URL. Browsers typically cache this response, meaning subsequent requests for the same short URL might go directly to the long URL, bypassing our server. HTTP/1.1 301 Moved Permanently Location: https://www.original-long-url.com 302 (Temporary Redirect) : This suggests that the resource is temporarily located at a different URL. Browsers do not cache this response, ensuring that future requests for the short URL will always go through our server first. HTTP/1.1 302 Found Location: https://www.original-long-url.com For URL Shortener, 302 redirect is preferred : It allows us to update or expire links as needed It allows us to track click statistics for each short URL Deep Dive 1. How can we ensure short urls are unique? i. Random Number Generation (Collision) input_url = \"https://www.example.com/some/very/long/url\" random_number = Math.random() short_code_encoded = base62_encode(random_number) short_code = short_code_encoded[:8] # 8 characters ii. Hash the long URL (Collision) iii. Unique counter with Base62 encoding simply increment a counter for each new url encode it using base62 encoding to ensure it's a compacted representation we can use Redis INCR command Being single-threaded means Redis processes one command at a time, eliminating race conditions 2. How can we ensure that redirects are fast? i. Add an index To avoid a full table scan, we can use a technique called indexing We should designate the short code as the primary key of our table. This automatically creates an index and ensures uniqueness. For databases that support it (like PostgreSQL), we can use hash indexing on the short code column. This provides O(1) average case lookup time, which is faster than B-tree for exact match queries ii. Implement an in-memory cache (redis) When a redirect request comes in, the server first checks the cache. If the short code is found in the cache (a cache hit), the server retrieves the long URL from the cache, significantly reducing latency. If not found (a cache miss), the server queries the database, retrieves the long URL, and then stores it in the cache for future requests. iii. Use a CDN The short URL domain is served through a CDN geographically distributed around the world. The CDN nodes cache the mappings of short codes to long URLs, allowing redirect requests to be handled close to the user's location 3. How can we scale to support 1B shortened urls and 100M DAU? Size of database (500 GB). We could always shard our data across multiple servers but a single Postgres instance, for example, should do for now. What if DB goes down? By using a database like Postgres that supports replication, we can create multiple identical copies of our database on different servers. If one server goes down, we can redirect to another. We can scale our Primary Server by separating the read and write operations. This introduces a microservice architecture where the Read Service handles redirects while the Write service handles the creation of new short urls. This separation allows us to scale each service independently based on their specific demands. Horizontally scaling our write service introduces a significant issue, we need a single source of truth for the counter. We could solve this by using a centralized Redis instance to store the counter. Now, when a user requests to shorten a url, the Write Service will get the next counter value from the Redis instance, compute the short code, and store the mapping in the database. Additional redis network request for each new write request? We could always use a technique called \"counter batching\" to reduce the number of network requests. Counter Batching : Each Write Service instance requests a batch of counter values from the Redis instance (e.g., 1000 values at a time). The Redis instance atomically increments the counter by 1000 and returns the start of the batch. The Write Service instance can then use these 1000 values locally without needing to contact Redis for each new URL. When the batch is exhausted, the Write Service requests a new batch. Final Design","title":"URL Shortener"},{"location":"system-design/url-shortener/#design-url-shortening-service","text":"","title":"Design URL Shortening Service"},{"location":"system-design/url-shortener/#functional-requirements","text":"Users should be able to submit a long URL and receive a shortened URL. Optionally, users should be able to specify a custom alias for the shortened URL. Optionally, users should be able to specify an expiration date for the shortened URL. Users should be able to access the original URL using the shortened URL.","title":"Functional Requirements"},{"location":"system-design/url-shortener/#non-functional-requirements","text":"Ensure uniqueness for the shortened URLs. (No two long URLs should map to the same short URL.) Redirection should occur with minimal latency. Availability > Consistency Support 1B shortened URLs (in total) & 100M DAU","title":"Non Functional Requirements"},{"location":"system-design/url-shortener/#capacity-estimation","text":"Storage Estimation : Assume metadata entry for each URL is 500 bytes. Short URL -> 8 bytes Long URL -> 100 bytes Created At -> 8 bytes User ID -> 8 bytes TTL -> 8 bytes Total Storage = 500 bytes * 1B = 500 GB Traffic Estimation : Assume 100M DAU with 10 requests per user per day Total Requests = 100M * 10 = 1B requests per day Total Requests per second = 1B / 10^5 = 10k request / second Assume 1% of requests are for shortening URLs Total Shortening Requests = 10k * 0.01 = 100 requests / second","title":"Capacity Estimation"},{"location":"system-design/url-shortener/#core-entities","text":"User Original URL Shortened URL","title":"Core Entities"},{"location":"system-design/url-shortener/#apis","text":"// Shorten a URL POST /urls { \"long_url\": \"https://www.example.com/some/very/long/url\", \"custom_alias\": \"optional_custom_alias\", \"expiration_date\": \"optional_expiration_date\" } -> { \"short_url\": \"http://short.ly/abc123\" } // Redirect to Original URL GET /{short_code} -> HTTP 302 Redirect to the original long URL","title":"APIs"},{"location":"system-design/url-shortener/#high-level-design","text":"1. Users should be able to submit a long URL and receive a shortened URL 2. Users should be able to access the original URL using the shortened URL","title":"High Level Design"},{"location":"system-design/url-shortener/#http-redirect-response","text":"301 (Permanent Redirect) : This indicates that the resource has been permanently moved to the target URL. Browsers typically cache this response, meaning subsequent requests for the same short URL might go directly to the long URL, bypassing our server. HTTP/1.1 301 Moved Permanently Location: https://www.original-long-url.com 302 (Temporary Redirect) : This suggests that the resource is temporarily located at a different URL. Browsers do not cache this response, ensuring that future requests for the short URL will always go through our server first. HTTP/1.1 302 Found Location: https://www.original-long-url.com For URL Shortener, 302 redirect is preferred : It allows us to update or expire links as needed It allows us to track click statistics for each short URL","title":"HTTP Redirect Response"},{"location":"system-design/url-shortener/#deep-dive","text":"1. How can we ensure short urls are unique? i. Random Number Generation (Collision) input_url = \"https://www.example.com/some/very/long/url\" random_number = Math.random() short_code_encoded = base62_encode(random_number) short_code = short_code_encoded[:8] # 8 characters ii. Hash the long URL (Collision) iii. Unique counter with Base62 encoding simply increment a counter for each new url encode it using base62 encoding to ensure it's a compacted representation we can use Redis INCR command Being single-threaded means Redis processes one command at a time, eliminating race conditions 2. How can we ensure that redirects are fast? i. Add an index To avoid a full table scan, we can use a technique called indexing We should designate the short code as the primary key of our table. This automatically creates an index and ensures uniqueness. For databases that support it (like PostgreSQL), we can use hash indexing on the short code column. This provides O(1) average case lookup time, which is faster than B-tree for exact match queries ii. Implement an in-memory cache (redis) When a redirect request comes in, the server first checks the cache. If the short code is found in the cache (a cache hit), the server retrieves the long URL from the cache, significantly reducing latency. If not found (a cache miss), the server queries the database, retrieves the long URL, and then stores it in the cache for future requests. iii. Use a CDN The short URL domain is served through a CDN geographically distributed around the world. The CDN nodes cache the mappings of short codes to long URLs, allowing redirect requests to be handled close to the user's location 3. How can we scale to support 1B shortened urls and 100M DAU? Size of database (500 GB). We could always shard our data across multiple servers but a single Postgres instance, for example, should do for now. What if DB goes down? By using a database like Postgres that supports replication, we can create multiple identical copies of our database on different servers. If one server goes down, we can redirect to another. We can scale our Primary Server by separating the read and write operations. This introduces a microservice architecture where the Read Service handles redirects while the Write service handles the creation of new short urls. This separation allows us to scale each service independently based on their specific demands. Horizontally scaling our write service introduces a significant issue, we need a single source of truth for the counter. We could solve this by using a centralized Redis instance to store the counter. Now, when a user requests to shorten a url, the Write Service will get the next counter value from the Redis instance, compute the short code, and store the mapping in the database. Additional redis network request for each new write request? We could always use a technique called \"counter batching\" to reduce the number of network requests. Counter Batching : Each Write Service instance requests a batch of counter values from the Redis instance (e.g., 1000 values at a time). The Redis instance atomically increments the counter by 1000 and returns the start of the batch. The Write Service instance can then use these 1000 values locally without needing to contact Redis for each new URL. When the batch is exhausted, the Write Service requests a new batch.","title":"Deep Dive"},{"location":"system-design/url-shortener/#final-design","text":"","title":"Final Design"},{"location":"system-design/whatsapp/","text":"","title":"Whatsapp"},{"location":"system-design/youtube-top-k/","text":"","title":"YouTube Top K"},{"location":"system-design/youtube/","text":"Design YouTube Capacity Estimation Assumptions - MAU (Monthly Active Users): 2 billion - DAU (Daily Active Users): 50% of MAU = 1 billion - Average video size: 50 MB - Video consumption per DAU: 5 videos - View to Upload ratio: 200 : 1 Video Views & Uploads per Day - Daily Video Views = 1 billion DAU * 5 videos = 5 billion views/day - Daily Video Uploads = 5 billion views/day / 200 = 25 million uploads/day Video Storage Calculation - Daily Storage = 25 million uploads/day * 50 MB = 1250 TB/day - With 3x encoding overhead = 3750 TB/day = 3.75 PB/day Bandwidth Calculation - Views Bandwidth = 5 billion views/day * 50 MB / 10^4 seconds = 5 * 10^9 * 50 * 10^6 / 10^4 = 25 TB/s - Upload Bandwidth = 25 TB / 200 / s = 125 GB/s QPS - Video Views per Second = 5 billion / 10^4 seconds = 500,000 QPS - Video Uploads per Second = 500,000 QPS / 200 = 2500 QPS Metadata Storage Calculation - Metadata Size = 1 KB per video & 0.5 KB per user - Storage time = 5 years = 5 * 400 days = 2000 days - 1 million new users/day (Assumption) - Video metadata storage = 2000 days * 25 million uploads/day * 1 KB = 50 TB - User metadata storage = 2000 days * 1 million new users/day * 0.5 KB = 1 TB","title":"YouTube"},{"location":"system-design/youtube/#design-youtube","text":"","title":"Design YouTube"},{"location":"system-design/youtube/#capacity-estimation","text":"Assumptions - MAU (Monthly Active Users): 2 billion - DAU (Daily Active Users): 50% of MAU = 1 billion - Average video size: 50 MB - Video consumption per DAU: 5 videos - View to Upload ratio: 200 : 1 Video Views & Uploads per Day - Daily Video Views = 1 billion DAU * 5 videos = 5 billion views/day - Daily Video Uploads = 5 billion views/day / 200 = 25 million uploads/day Video Storage Calculation - Daily Storage = 25 million uploads/day * 50 MB = 1250 TB/day - With 3x encoding overhead = 3750 TB/day = 3.75 PB/day Bandwidth Calculation - Views Bandwidth = 5 billion views/day * 50 MB / 10^4 seconds = 5 * 10^9 * 50 * 10^6 / 10^4 = 25 TB/s - Upload Bandwidth = 25 TB / 200 / s = 125 GB/s QPS - Video Views per Second = 5 billion / 10^4 seconds = 500,000 QPS - Video Uploads per Second = 500,000 QPS / 200 = 2500 QPS Metadata Storage Calculation - Metadata Size = 1 KB per video & 0.5 KB per user - Storage time = 5 years = 5 * 400 days = 2000 days - 1 million new users/day (Assumption) - Video metadata storage = 2000 days * 25 million uploads/day * 1 KB = 50 TB - User metadata storage = 2000 days * 1 million new users/day * 0.5 KB = 1 TB","title":"Capacity Estimation"},{"location":"system-design/technologies/api-gateway/","text":"","title":"Api gateway"},{"location":"system-design/technologies/cassandra/","text":"","title":"Cassandra"},{"location":"system-design/technologies/clickhouse/","text":"","title":"Clickhouse"},{"location":"system-design/technologies/dynamodb/","text":"","title":"Dynamodb"},{"location":"system-design/technologies/elastic-search/","text":"","title":"Elastic search"},{"location":"system-design/technologies/flink/","text":"","title":"Flink"},{"location":"system-design/technologies/kafka/","text":"","title":"Kafka"},{"location":"system-design/technologies/postegresql/","text":"","title":"Postegresql"},{"location":"system-design/technologies/redis/","text":"","title":"Redis"},{"location":"system-design/technologies/spark/","text":"","title":"Spark"},{"location":"system-design/technologies/zookeeper/","text":"","title":"Zookeeper"}]}