<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <title>Greedy &mdash; Software Engineering Notes</title>
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css">
    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.8.1/css/all.css">
    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.8.1/css/v4-shims.css">
    <link rel="stylesheet" href="../../css/theme.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
    <script src="//code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script> 
</head>

<body ontouchstart="">
    <div id="container">
        <aside>
            <div class="home">
                <div class="title">
                    <button class="hamburger"></button>
                    <a href="../.." class="site-name"> Software Engineering Notes</a>
                </div>
                <div class="search">
                    <div role="search">
    <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
        <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
    </form>
</div>
                </div>
            </div>
            <nav class="nav">
                <ul class="root">
                    <li class="toctree-l1"><a class="nav-item" href="../..">Home</a></li>
                    <li class="toctree-l1"><button class="section nav-item">Algorithms</button>
<ul class="subnav">
    <li class="toctree-l2"><a class="nav-item" href="../backtracking/">Backtracking</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../data-structures/">Data Structures</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../dynamic-programming/">Dynamic Programming</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../graph/">Graphs</a></li>
    <li class="toctree-l2 current"><a class="nav-item current" href="./">Greedy</a>
<ul class="subnav">
<li class="toctree-l3"><a class="nav-item toc" href="#characteristics-of-greedy-algorithms">Characteristics of Greedy Algorithms</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#common-greedy-problems">Common Greedy Problems</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#when-to-use-greedy-algorithms">When to Use Greedy Algorithms</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#advantages-of-greedy-algorithms">Advantages of Greedy Algorithms</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#disadvantages-of-greedy-algorithms">Disadvantages of Greedy Algorithms</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#greedy-vs-dynamic-programming">Greedy vs. Dynamic Programming</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#when-greedy-fails-counterexamples">When Greedy Fails: Counterexamples</a></li>
<li class="toctree-l3"><a class="nav-item toc" href="#real-world-applications">Real-World Applications</a></li>
</ul></li>
    <li class="toctree-l2"><a class="nav-item" href="../math/">Math</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../searching/">Searching</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../sorting/">Sorting</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../string/">Strings</a></li>
</ul></li>
                    <li class="toctree-l1"><button class="section nav-item">C++</button>
<ul class="subnav">
    <li class="toctree-l2"><a class="nav-item" href="../../cpp/stl/">STL</a></li>
</ul></li>
                    <li class="toctree-l1"><button class="section nav-item">System Design</button>
<ul class="subnav">
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/ad-click-aggregator/">Ad Click Aggregator</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/dropbox/">Dropbox</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/live-comments/">Live Comments</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/ticketmaster/">Ticketmaster</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../../system-design/tinder/">Tinder</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/uber/">Uber</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/whatsapp/">Whatsapp</a></li>
    <li class="toctree-l2"><a class="nav-item" href="../../system-design/youtube/">YouTube</a></li>
    <li class="toctree-l2">
<a class="nav-item" href="../../system-design/youtube-top-k/">YouTube Top K</a></li>
</ul></li>
                    <li class="toctree-l1"><button class="section nav-item">Object Oriented Programming</button>
<ul class="subnav">
    <li class="toctree-l2"><button class="section nav-item hide">Java</button>
<ul class="subnav hide">
    <li class="toctree-l3"><a class="nav-item" href="../../oop/java/concepts/">Concepts</a></li>
    <li class="toctree-l3"><a class="nav-item" href="../../oop/java/solid-principles/">Solid Principles</a></li>
    <li class="toctree-l3"><a class="nav-item" href="../../oop/java/design-patterns/">Design Patterns</a></li>
</ul></li>
    <li class="toctree-l2"><button class="section nav-item hide">C++</button>
<ul class="subnav hide">
    <li class="toctree-l3"><a class="nav-item" href="../../oop/cpp/concepts/">Concepts</a></li>
    <li class="toctree-l3"><a class="nav-item" href="../../oop/cpp/solid-principles/">Solid Principles</a></li>
    <li class="toctree-l3"><a class="nav-item" href="../../oop/cpp/design-patterns/">Design Patterns</a></li>
</ul></li>
</ul></li>
                </ul>
            </nav>
            <div class="repo">
    <div class="link">
        <a href="https://github.com/RafsanMazumder/notes" class="fa fa-github"> GitHub</a>
    </div>
    <div class="previous"><a href="../graph/">&laquo; Previous</a></div>
    <div class="next"><a href="../math/">Next &raquo;</a></div>
</div>
        </aside>
        <div id="spacer"><button class="arrow"></button></div>
        <main>
            <div class="home-top">
                <button class="hamburger"></button>
                <a href="../.." class="site-name"> Software Engineering Notes</a>
            </div>
            <div id="main">
                <nav class="breadcrumbs">
<ul>
    <li>Algorithms</li>
</ul>
</nav>
                <div id="content"><h1 id="greedy-algorithms">Greedy Algorithms</h1>
<p>Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum. They are typically used for optimization problems.</p>
<h2 id="characteristics-of-greedy-algorithms">Characteristics of Greedy Algorithms</h2>
<ol>
<li><strong>Greedy Choice Property</strong>: A global optimum can be reached by making locally optimal choices.</li>
<li><strong>Optimal Substructure</strong>: An optimal solution contains optimal solutions to its subproblems.</li>
<li><strong>Simple Implementation</strong>: Usually easier to implement compared to other techniques.</li>
<li><strong>No Backtracking</strong>: Once a decision is made, it is never reconsidered.</li>
</ol>
<h2 id="common-greedy-problems">Common Greedy Problems</h2>
<h3 id="1-coin-change-with-specific-coin-systems">1. Coin Change (with specific coin systems)</h3>
<p>For coin systems like US currency (1, 5, 10, 25), a greedy approach works.</p>
<pre><code class="language-cpp">vector&lt;int&gt; greedyCoinChange(int amount, vector&lt;int&gt;&amp; coins) {
    // Sort coins in descending order
    sort(coins.rbegin(), coins.rend());

    vector&lt;int&gt; result;

    for (int coin : coins) {
        while (amount &gt;= coin) {
            result.push_back(coin);
            amount -= coin;
        }
    }

    return result;
}
</code></pre>
<p><strong>Note</strong>: This doesn't work for all coin systems. For example, with coins {1, 3, 4} and amount 6, the optimal solution is two 3's, not a 4 and two 1's.</p>
<h3 id="2-activity-selection">2. Activity Selection</h3>
<p>Select the maximum number of activities that don't overlap.</p>
<pre><code class="language-cpp">vector&lt;int&gt; activitySelection(vector&lt;pair&lt;int, int&gt;&gt;&amp; activities) {
    // Sort by end time
    sort(activities.begin(), activities.end(), 
         [](pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) {
             return a.second &lt; b.second;
         });

    vector&lt;int&gt; selected;
    selected.push_back(0);  // First activity is always selected

    int lastEnd = activities[0].second;

    for (int i = 1; i &lt; activities.size(); i++) {
        // If this activity starts after the last selected activity ends
        if (activities[i].first &gt;= lastEnd) {
            selected.push_back(i);
            lastEnd = activities[i].second;
        }
    }

    return selected;
}
</code></pre>
<h3 id="3-fractional-knapsack">3. Fractional Knapsack</h3>
<p>Unlike 0/1 Knapsack, we can take fractions of items.</p>
<pre><code class="language-cpp">double fractionalKnapsack(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; weights, int capacity) {
    int n = values.size();
    vector&lt;pair&lt;double, int&gt;&gt; valuePerWeight(n);

    for (int i = 0; i &lt; n; i++) {
        valuePerWeight[i] = {(double)values[i] / weights[i], i};
    }

    // Sort by value per weight in descending order
    sort(valuePerWeight.rbegin(), valuePerWeight.rend());

    double totalValue = 0.0;

    for (auto&amp; [ratio, index] : valuePerWeight) {
        if (capacity &gt;= weights[index]) {
            // Take the whole item
            totalValue += values[index];
            capacity -= weights[index];
        } else {
            // Take a fraction of the item
            totalValue += values[index] * ((double)capacity / weights[index]);
            break;
        }
    }

    return totalValue;
}
</code></pre>
<h3 id="4-huffman-coding">4. Huffman Coding</h3>
<p>A lossless data compression algorithm.</p>
<pre><code class="language-cpp">struct Node {
    char data;
    int freq;
    Node *left, *right;

    Node(char data, int freq) : data(data), freq(freq), left(nullptr), right(nullptr) {}
};

struct Compare {
    bool operator()(Node* a, Node* b) {
        return a-&gt;freq &gt; b-&gt;freq;
    }
};

unordered_map&lt;char, string&gt; huffmanCodes;

void generateCodes(Node* root, string code) {
    if (!root) return;

    if (root-&gt;data != '\0') {
        huffmanCodes[root-&gt;data] = code;
    }

    generateCodes(root-&gt;left, code + &quot;0&quot;);
    generateCodes(root-&gt;right, code + &quot;1&quot;);
}

void huffmanCoding(string text) {
    unordered_map&lt;char, int&gt; freq;
    for (char c : text) {
        freq[c]++;
    }

    priority_queue&lt;Node*, vector&lt;Node*&gt;, Compare&gt; pq;

    for (auto&amp; pair : freq) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() &gt; 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('\0', left-&gt;freq + right-&gt;freq);
        parent-&gt;left = left;
        parent-&gt;right = right;

        pq.push(parent);
    }

    Node* root = pq.top();
    generateCodes(root, &quot;&quot;);

    cout &lt;&lt; &quot;Huffman Codes:&quot; &lt;&lt; endl;
    for (auto&amp; pair : huffmanCodes) {
        cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; endl;
    }
}
</code></pre>
<h3 id="5-minimum-spanning-tree-prims-algorithm">5. Minimum Spanning Tree (Prim's Algorithm)</h3>
<pre><code class="language-cpp">int primMST(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph) {
    int n = graph.size();
    vector&lt;bool&gt; inMST(n, false);
    vector&lt;int&gt; key(n, INT_MAX);

    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
    key[0] = 0;
    pq.push({0, 0});  // {weight, vertex}

    int totalWeight = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        int weight = pq.top().first;
        pq.pop();

        if (inMST[u]) continue;

        inMST[u] = true;
        totalWeight += weight;

        for (auto&amp; [v, w] : graph[u]) {
            if (!inMST[v] &amp;&amp; w &lt; key[v]) {
                key[v] = w;
                pq.push({key[v], v});
            }
        }
    }

    return totalWeight;
}
</code></pre>
<h3 id="6-dijkstras-algorithm-shortest-path">6. Dijkstra's Algorithm (Shortest Path)</h3>
<pre><code class="language-cpp">vector&lt;int&gt; dijkstra(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, int start) {
    int n = graph.size();
    vector&lt;int&gt; dist(n, INT_MAX);
    dist[start] = 0;

    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
    pq.push({0, start});

    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();

        if (d &gt; dist[u]) continue;

        for (auto&amp; [v, weight] : graph[u]) {
            if (dist[u] + weight &lt; dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }

    return dist;
}
</code></pre>
<h3 id="7-job-sequencing-with-deadlines">7. Job Sequencing with Deadlines</h3>
<pre><code class="language-cpp">struct Job {
    int id, deadline, profit;
};

vector&lt;int&gt; jobSequencing(vector&lt;Job&gt;&amp; jobs) {
    // Sort jobs by profit in descending order
    sort(jobs.begin(), jobs.end(), [](Job&amp; a, Job&amp; b) {
        return a.profit &gt; b.profit;
    });

    // Find the maximum deadline
    int maxDeadline = 0;
    for (Job&amp; job : jobs) {
        maxDeadline = max(maxDeadline, job.deadline);
    }

    vector&lt;int&gt; slot(maxDeadline + 1, -1);
    vector&lt;int&gt; sequence;
    int totalProfit = 0;

    for (Job&amp; job : jobs) {
        // Find a free slot before the deadline
        for (int i = job.deadline; i &gt; 0; i--) {
            if (slot[i] == -1) {
                slot[i] = job.id;
                totalProfit += job.profit;
                sequence.push_back(job.id);
                break;
            }
        }
    }

    cout &lt;&lt; &quot;Total profit: &quot; &lt;&lt; totalProfit &lt;&lt; endl;
    return sequence;
}
</code></pre>
<h2 id="when-to-use-greedy-algorithms">When to Use Greedy Algorithms</h2>
<p>Greedy algorithms are appropriate when:</p>
<ol>
<li><strong>The problem has optimal substructure</strong></li>
<li><strong>The greedy choice is consistent with global optimal</strong></li>
<li><strong>Local optimizations lead to global optimization</strong></li>
</ol>
<h2 id="advantages-of-greedy-algorithms">Advantages of Greedy Algorithms</h2>
<ol>
<li><strong>Simple and intuitive</strong></li>
<li><strong>Often efficient (typically O(n log n) due to sorting)</strong></li>
<li><strong>Doesn't require looking at all possibilities</strong></li>
</ol>
<h2 id="disadvantages-of-greedy-algorithms">Disadvantages of Greedy Algorithms</h2>
<ol>
<li><strong>Doesn't always yield the optimal solution</strong></li>
<li><strong>Difficult to prove correctness (requires mathematical proof)</strong></li>
<li><strong>Short-sighted approach might miss better solutions</strong></li>
</ol>
<h2 id="greedy-vs-dynamic-programming">Greedy vs. Dynamic Programming</h2>
<table>
<thead>
<tr>
<th>Greedy</th>
<th>Dynamic Programming</th>
</tr>
</thead>
<tbody>
<tr>
<td>Makes locally optimal choices</td>
<td>Considers all possible choices</td>
</tr>
<tr>
<td>No guarantee of global optimum</td>
<td>Always finds the global optimum</td>
</tr>
<tr>
<td>Typically faster</td>
<td>Typically slower but more thorough</td>
</tr>
<tr>
<td>No overlapping subproblems needed</td>
<td>Relies on overlapping subproblems</td>
</tr>
<tr>
<td>No memorization</td>
<td>Uses memoization or tabulation</td>
</tr>
<tr>
<td>Examples: Fractional Knapsack</td>
<td>Examples: 0/1 Knapsack</td>
</tr>
</tbody>
</table>
<h2 id="when-greedy-fails-counterexamples">When Greedy Fails: Counterexamples</h2>
<ol>
<li><strong>Coin Change</strong>: For denominations {1, 3, 4} and amount 6, greedy gives {4, 1, 1} (3 coins), but optimal is {3, 3} (2 coins).</li>
<li><strong>0/1 Knapsack</strong>: Choosing items by value/weight ratio doesn't always yield optimal solution.</li>
</ol>
<h2 id="real-world-applications">Real-World Applications</h2>
<ol>
<li><strong>Network routing protocols</strong></li>
<li><strong>Data compression (Huffman coding)</strong></li>
<li><strong>Task scheduling</strong></li>
<li><strong>Resource allocation</strong></li>
<li><strong>Load balancing in distributed systems</strong></li>
</ol></div>
                <footer>
    <div class="footer-buttons">
        <div class="previous"><a href="../graph/" title="Graphs"><span>Previous</span></a></div>
        <div class="next"><a href="../math/" title="Math"><span>Next</span></a></div>
    </div>
    <div class="footer-note">
        <p>
            Built with <a href="http://www.mkdocs.org">MkDocs</a> using
            <a href="https://github.com/daizutabi/mkdocs-ivory">Ivory theme</a>.
        </p>
    </div>
</footer>
            </div>
        </main>
    </div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js"></script>
    <script src="../../search/main.js"></script>
</body>

</html>